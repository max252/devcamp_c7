# ¿Qué diferencia a Javascript de cualquier otro lenguaje de programación?

**JavaScript** es un lenguaje de programación utilizado principalmente en la web. Con su ayuda, los sitios web se vuelven interactivos: agregan ventanas emergentes, animaciones, botones y formularios para enviar información. También se le llama el idioma principal de la interfaz: el lado "frontal" del sitio con el que interactúan los usuarios.

**JavaScript** es similar a Java, Python, Go, C#, pero tiene sus propias características:

1. Interpretado, no compilado. Todos los lenguajes de programación se dividen en dos grupos. El código en lenguajes compilados debe ejecutarse primero a través de un programa especial, un compilador, y solo entonces se puede utilizar. La mayoría de los lenguajes modernos están compilados, a diferencia de **JavaScript**.

No es necesario compilar el código en un lenguaje interpretado. Se escribe y se pasa inmediatamente al programa intérprete, que lo ejecuta inmediatamente. Esto acelera el desarrollo, pero requiere ejecutarse solo junto con el intérprete. Es cierto que el intérprete de **JavaScript** está integrado en todos los navegadores modernos, por lo que no hay problemas al ejecutar el código.

2. Multiparadigma. Existen varios paradigmas en programación:

- Objeto. En él se crean objetos para cada entidad del código, por ejemplo un botón de pedido. Y luego se escriben las conexiones entre estos objetos.
- Funcional. Presta más atención a instrucciones específicas. El botón aquí no es un objeto; en el código se designa como el orden de las acciones que ocurren después de hacer clic.
- Imperativo. Aquí el código se escribe como un conjunto claro de instrucciones que se ejecutan de forma estrictamente secuencial. Los paradigmas imperativo y funcional a menudo se utilizan juntos.

A menudo, los idiomas se centran en trabajar con un paradigma. **JavaScript** es diferente: no dicta cómo se escribe el código y le permite ceñirse a diferentes estilos y técnicas.

3. Sin tipificación estricta. Existen lenguajes de programación con tipado estático. Si crea una variable, primero debe especificar su tipo, por ejemplo, un número. Y en él no se puede almacenar nada más que un número.

**JavaScript** tiene escritura dinámica: puedes poner cualquier cosa en una variable. Esto facilita la escritura de código, pero puede provocar errores. Por ejemplo, **JavaScript** te permitirá comparar una cadena con un número e incluso producir algún tipo de resultado. ¿Qué es más grande, "vaca" o "81"? **JavaScript** conoce la respuesta.

4. Integrado con HTML y CSS en navegadores. HTML y CSS son lenguajes de marcado para sitios web. No son lenguajes de programación porque no te permiten escribir funciones ni procesar nada. Con su ayuda, configuran la apariencia del sitio: la ubicación de los bloques, el tamaño de fuente, los colores. Para hacer que un sitio web sea interactivo, necesita un lenguaje de programación y **JavaScript** encaja perfectamente aquí. Los navegadores modernos le permiten simplemente escribir código **JavaScript** directamente en su formato HTML y CSS y funcionará.

A menudo, por conveniencia, los scripts se escriben en archivos separados y luego se inserta una referencia al archivo en el código. Esto le permite evitar sobrecargar el código en la página y utilizar los mismos scripts en diferentes lugares sin tener que reescribirlos.

5. Adecuado para backend. El código **JavaScript** se puede ejecutar tanto en el navegador como en el servidor. Esto significa que puede usarlo para escribir no solo elementos interactivos de la página, sino también la parte del servidor del sitio: procesamiento de datos y funciones de cálculo. Sin embargo, para ello es necesario dominar una herramienta independiente: Node.js. Este es un motor que le permite ejecutar JavaScript no en el navegador, sino en el servidor.

---

---

# ¿Cuáles son algunos tipos de datos JS?

**JavaScript (JS)** es un lenguaje de programación de **tipo dinámico**. Esto significa que al declarar una variable, no es necesario especificar su tipo de datos; se determinará automáticamente al asignar un valor.

Hay ocho tipos de datos en JS: number, string, boolean, undefined, object, bigInt, symbol y null.

## number

El tipo de datos **number** es numérico. Si escribe el valor de una variable como un número, como en el código siguiente, JS lo determinará automáticamente como **number**:

```JavaScript
let age = 30;
```

Puedes realizar varias operaciones matemáticas con números en JS: suma (+), resta (-), multiplicación (\*) y división. Podría verse así, por ejemplo:

```JavaScript
let quantity = 10;
let price = 2.99;
let total = quantity * price;
console.log(total); // 29.9
```

En el ejemplo anterior, a la variable "cantidad" se le asigna el valor 10 (un número entero) y a la variable "precio" se le asigna el valor 2,99 (un número de punto flotante). En la variable "total", el precio se multiplica por la cantidad y el resultado se envía a la consola.

## string

El texto entre comillas simples (') o dobles (") se asigna automáticamente al lenguaje de programación como un tipo de datos **string**.

```JavaScript
let name = "Adam";
```

Es importante aclarar que las cadenas en JS son inmutables: no se puede reemplazar un carácter individual una vez creado. Puede realizar varias operaciones con cadenas ya preparadas, incluida su combinación, como en el siguiente ejemplo:

```JavaScript
let firstName = "Adam";
let lastName = "Balkoev";
let fullName = firstName + " " + lastName;
// fullName will be "Adam Balkoev"
```

## boolean

El siguiente tipo de datos en JS es **boolean**. Este es un tipo booleano que sólo puede tomar dos valores: **true** o **false**, verdadero o falso.

Por ejemplo, si creamos una variable _haveCar_ con el valor _true_, JS determinará automáticamente que el tipo es **boolean**.

Este tipo de datos se utiliza a menudo en sentencias _if_ y bucles _for_ y le ayuda a comprender qué parte del código ejecutar. Por ejemplo:

```JavaScript
let isTrue = true;
let isFalse = false;

if (isTrue) {
  console.log("The value is true");
} else {
  console.log("The value is false");
}
```

## null

**null** en JS es otro tipo de datos que tiene el significado de "nada" o "valor desconocido".

Creemos una variable papelera (papelera) con un valor vacío, lo que indica que no sabemos qué hay en la papelera:

```JavaScript
let trash = null;
```

## undefined

Si crea una variable en JS y no le asigna ningún valor, el lenguaje de programación determinará automáticamente el tipo de datos que contiene como **undefined**.

Veamos un ejemplo: cree una variable _box_ con un valor vacío, lo que indica que todavía no hay nada en el cuadro:

```JavaScript
let box;
condole.log(box) // undefined
```

## object

Veamos este tipo con un ejemplo. Escribamos un objeto _shop_, dentro del cual colocaremos varias propiedades: nombre, descripción y número de departamentos.

```JavaScript
let shop = {
  title: "Goshan",
  description: "Some text",
  countShop: 10,
}
```

JS asignará automáticamente el valor de esta variable al tipo **object**. Al determinar un tipo de datos, el lenguaje de programación no comprueba lo que hay dentro del objeto: ve la estructura y la utiliza para determinar el tipo.

## bigInt

**BigInt** es un objeto integrado que proporciona una manera de representar números enteros mayores que 2 53, que es el número más grande que JavaScript puede representar de manera confiable usando la primitiva Número.

```JavaScript
let bigInt = 19241924124n;
console.log(bigInt); // 19241924124n
console.log(typeof bigInt); // bigInt
```

## symbol

**symbol** es un tipo de datos especial. El propósito de los valores **symbol** es servir como nombres especiales para indicar propiedades especiales de los objetos.

```JavaScript
const sym1 = Symbol();
const sym2 = Symbol("foo");
const sym3 = Symbol("foo");
```

## Palabra clave typeof

El operador **typeof** le permite determinar qué tipo de datos se esconden detrás de una variable en particular.

Dado que JS asigna tipos de datos automáticamente, a veces es útil saber cómo ve el lenguaje el valor de una variable. Para ver el tipo de datos en la terminal, debe escribir una consola con una palabra clave y especificar una variable. Por ejemplo, así:

```JavaScript
let name = "Adam";
console.log(typeof name); // string

let age = 30;
console.log(typeof age); // number
```

---

---

# ¿Cuáles son las tres funciones de String en JS?

**String** es un tipo de datos de JavaScript para representar una secuencia arbitraria de caracteres.

JavaScript siempre usa codificación **UTF-16** para cadenas. No depende de qué codificación esté configurada para la página HTML.

Crear una línea es muy sencillo. Para ello, solo necesitas colocar los símbolos necesarios entre:

- comillas simples ';
- doble comillas ";
- comillas invertidas `.

Por ejemplo:

```JavaScript
let name1 = 'Alexander';
let name2 = "Alexander";
let name3 = `Alexander`;
```

En el ejemplo anterior, tenemos tres filas asignadas a diferentes variables. Para asegurarnos de que sean todas cadenas, podemos verificar el tipo de variable:

```JavaScript
console.log(typeof(name1)); // string
console.log(typeof(name2)); // string
console.log(typeof(name3)); // String
```

Es importante saber que las cadenas en JavaScript son inmutables. Esto significa que una vez creada una cadena, su contenido no se puede cambiar. Para ello, simplemente necesitamos crear una nueva cadena y, por ejemplo, asignarla a la misma variable:

```JavaScript
let str = 'Go';
str = 'g' + str[1]; // "go"
console.log(str); // "go"
```

La cadena no puede contener ningún carácter:

```JavaScript
const str1 = '';
const str2 = "";
const str3 = ``;
```

Estas líneas se llaman vacías.

## Concatenación de cadenas

En JavaScript, la concatenación (unión) de dos o más cadenas en una se realiza mediante el operador +:

```JavaScript
const firstName = 'Marcus';
const lastName = 'Wolfe';
const fullName = firstName + ' ' + lastName;
console.log(fullName); // "Marcus Wolfe"
```

En este ejemplo, agregamos un espacio (' ') entre las cadenas contenidas en las variables _firstName_ y _lastName_.

Otra forma de concatenar cadenas en JavaScript es utilizar el método **concat()**:

```JavaScript
const firstName = 'Marcus';
const lastName = 'Wolfe';
const fullName = firstName.concat(' ', lastName);
console.log(fullName); // "Marcus Wolfe"
```

En JavaScript, también puedes usar cadenas de plantilla para concatenar cadenas:

```JavaScript
const firstName = 'Marcus';
const lastName = 'Wolfe';
const fullName = `${firstName} ${lastName}`;
console.log(fullName); // "Marcus Wolfe"
```

## Cadenas de plantilla

Como señalamos anteriormente, las cadenas comodín son una forma de crear cadenas usando comillas invertidas (`). Aparecieron en el lenguaje mucho más tarde que las cadenas ordinarias y, a diferencia de ellas, tienen una serie de características adicionales.

```JavaScript
const mySkill = `* HTML
* CSS
* JavaScript`;
```

Para crear cadenas de varias líneas utilizando comillas simples y dobles, debe utilizar el carácter de nueva línea (\n):

```JavaScript
const mySkill = '* HTML\n* CSS\n* JavaScript';
```

Puede colocar dicha cadena en varias líneas solo usando el operador +:

```JavaScript
const mySkill = '* HTML\n' +
'* CSS\n' +
'* JavaScript';
```

Otra diferencia con la cadena de plantilla es que puede incluir expresiones ${...}:

```JavaScript
const name = 'Alexander';
const greeting = `Hi, ${name.toUpperCase()}.`; // "Hi, ALEXANDER."
```

## Personajes que escapan

En JavaScript, incluir un carácter en una cadena que se utiliza para crearla se realiza mediante escape. La barra invertida \ se utiliza como carácter de escape:

```JavaScript
const str1 = "He said, \"I love JavaScript!\""; // He said, "I love JavaScript!"
const str2 = 'It\'s a lovely day'; // It's a lovely day
const str3 = `$ echo \`hello\``; // $ echo `hello`
```

Si no se hace esto, se arrojará un error:

```JavaScript
str = "He said, "I learned from itchief!""; // Uncaught SyntaxError: Unexpected identifier 'I'
```

Además de escapar, en este caso simplemente puedes usar otra cita:

```JavaScript
const str1 = 'He said, "I love JavaScript!"'; // He said, "I love JavaScript!"
const str2 = `It's a lovely day`; // It's a lovely day
const str3 = "$ echo `hello`"; // $ echo `hello`
```

Además, el carácter de escape también se utiliza para insertar caracteres especiales en el texto. Por ejemplo:

- \n - avance de línea;
- \ - barra invertida;
- \t es un carácter de tabulación.

## Longitud de la cuerda

Obtener la longitud de una cuerda, es decir la cantidad de caracteres que lo componen se realiza en JavaScript usando la propiedad **lenght**:

```JavaScript
const mystr = 'My string';
// get length
const len = mystr.length;
console.log(len); // 9
```

## Acceso a los símbolos

Puede extraer un carácter específico de una cadena usando corchetes. Dentro de los corchetes debes colocar un número (el número de serie del personaje). El conteo de caracteres en una línea comienza desde 0:

```JavaScript
const str = 'Welcome';
// get first symbol
console.log(str[0]); // "W"
// get second symbol
console.log(str[1]); // "e"
// get last symbol
console.log(str[str.length - 1]); // "e"
```

Al pasar el índice de un símbolo inexistente, obtenemos _undefined_:

```JavaScript
const name = 'Zoe';
console.log(str[-1]); // undefined
console.log(str[3]); // undefined
```

Además, puede obtener un carácter de cadena por su número de serie utilizando métodos especiales diseñados para este caso: **charAt** y **at**.

```JavaScript
const str = 'Welcome';
console.log(str.charAt[2]); // "l"
console.log(str.at[3]); // "c"
```

El método **at** apareció en el lenguaje más tarde y, a diferencia de **chartAt**, es más flexible. Si se le pasa un número negativo como entrada, entonces el carácter en este caso se contará desde el final de la línea.

```JavaScript
const fruit = 'Banana';
console.log(fruit.at[-1]); // "a"
console.log(fruit.at[-2]); // "n"
```

También puedes hacer esto usando **slice**:

```JavaScript
const str = 'Welcome';
console.log(str.slice(2, 0)); // "l"
console.log(str.slice(3, 0)); // "c"
```

Si necesita iterar a través de una cadena carácter por carácter, puede usar bucles. Por ejemplo, **for** o **for...of**:

```JavaScript
const name = 'Tess';
const len = name.length;
// for
for (let i = 0; i < len; i++) {
  console.log(name[i]); // "T", "e", "s", "s"
}
// for..of
for (let char of name) {
  console.log(char); // "T", "e", "s", "s"
}
```

## Métodos de cadenas

Aunque las cadenas son un tipo de datos primitivo, se comportan como objetos en JavaScript. Por lo tanto, al trabajar con ellos, tenemos a nuestra disposición varias propiedades y métodos. Por ejemplo:

```JavaScript
// length
'Hello'.length; // 5
// concat
'Hello'.concat(', Alexander'); // "Hello, Alexander"
```

¿Cómo funciona esto en JavaScript? Aquí todo es muy sencillo. Cuando se accede a una propiedad o método, la cadena se envuelve en un contenedor especial _new String()_. Esto crea una nueva instancia de la clase String, que a su vez tiene acceso a estas propiedades y métodos. Es decir, en esencia, el motor JavaScript internamente hace algo como lo siguiente:

```JavaScript
// type 'Hello'
typeof 'Hello'; // "string"
// type new String('Hello')
typeof new String('Hello'); // "object"

(new String('Hello')).length; // 5
(new String('Hello')).concat(', Alexander'); // "Hello, Alexander"
```

Pero no es necesario utilizar _new String()_ directamente para crear cadenas en JavaScript. Se utiliza, como señalamos anteriormente, de forma automática, como envoltorio sobre una cadena para que podamos trabajar con ella como con un objeto.

La función _Sring_ en sí sin _new_ se puede utilizar cuando necesites convertir algún valor a una cadena:

```J
String(5); // "5"
String(true); // "true"
```

Otra forma de convertir un valor en una cadena es utilizar el método **toString()**:

```J
(5).toString(); // "5"
true.toString(); // "true"
```

**String** contiene muchos métodos para realizar diversas operaciones en cadenas. Ya hemos comentado algunos de ellos anteriormente. Estos son: **concat()**, **at()**, **slice()** y otros. Ahora veamos qué otros métodos interesantes están disponibles en **String** para trabajar con cadenas.

### Métodos para encontrar una subcadena en una cadena:

- **indexOf(substring [, start])** – devuelve el índice desde el cual comienza la subcadena buscada en la cadena;
- **lastIndexOf(substring, [, start])** es lo mismo que indexOf, solo que la búsqueda se realiza desde el final de la cadena.

```JavaScript
const vegetables = 'Tomato, Potato, Carrot, Tomato';
vegetables.indexOf('Tomato', 5); // 24

const fruits = 'Banana, Peach, Pear, Peach';
fruits.lastIndexOf('Peach', 10); // 8
```

El parámetro _start_ es opcional. Se utiliza cuando necesita especificar desde qué carácter de una cadena desea comenzar la búsqueda. Si no lo pasas al método, la búsqueda se realizará desde el principio de la línea.

```JavaScript
const vegetables = 'Tomato, Potato, Carrot, Tomato';
vegetables.indexOf('Tomato'); // 0

const fruits = 'Banana, Peach, Pear, Peach';
fruits.lastIndexOf('Peach'); // 21
```

Si no se encuentra la subcadena especificada, estos métodos devuelven -1 como resultado.

```JavaScript
const vegetables = 'Tomato, Potato, Carrot, Tomato';
vegetables.indexOf('Broccoli'); // -1

const fruits = 'Banana, Peach, Pear, Peach';
fruits.lastIndexOf('Peach', 5); // -1
```

En el caso de que necesite verificar si la cadena especificada contiene lo que está buscando, simplemente puede usar el método **includes**:

```JavaScript
const vegetables = 'Tomato, Potato, Carrot, Tomato';
vegetables.includes('Carrot'); // true

// indexOf
vegetables.indexOf('Carrot') > -1; // true
```

Este método devuelve _true_ si se encuentra la cadena de búsqueda. De lo contrario, _false_.

Para buscar desde una posición específica, sólo necesitas pasarla al segundo argumento **includes**:

```JavaScript
const file = 'index.html';
file.includes('.html', file.length - 5); // true
```

Puede comprobar la coherencia del principio y el final de una cadena en JavaScript muy fácilmente utilizando los métodos especiales **startWith** y **EndsWith**:

```JavaScript
const href = 'https://itchief.ru/javascript/';
href.startsWith('https://itchief.ru'); // true

const file = 'index.html';
file.endsWith('.html'); // true
```

### Métodos para obtener una subcadena:

**substring(start [, end])** – parte de la cadena entre **start** y **end** (sin incluir);
**substr(start [, length])** – parte de la cadena que comienza en el índice **start** con longitud **lengh**;
**slice(start [, end])** – parte de la cadena entre **start** y **end** (sin incluir);

Ejemplos de uso del método **substring**:

```JavaScript
const greeting = 'Hello, Bob! How are you?';
// si no se especifica el segundo argumento, hasta el final de la línea
greeting.substring(7); // "Bob! How are you?"
greeting.substring(7, 10); // "Bob"
// si el inicio es mayor que el final, funcionará igual que si se intercambiaran los argumentos
greeting.substring(10, 7); // "Bob"
// si los argumentos son iguales, obtenemos una cadena vacía
greeting.substring(7, 7); // ""
// los argumentos negativos se interpretan como 0
greeting.substring(5, -2); // "Hello"
```

Ejemplos de uso del método **substr**:

```JavaScript
const greeting = 'Hello, Bob! How are you?';
greeting.substr(7); // "Bob! How are you?"
greeting.substr(7, 3); // "Bob"
greeting.substr(-17, 3); // "Bob"
```

Ejemplos de uso del método **slice**:

```JavaScript
const greeting = 'Hello, Bob! How are you?';

greeting.slice(7); // "Bob! How are you?"
greeting.slice(7, 10); // "Bob"
greeting.slice(10, 7); // ""
greeting.slice(-17, -14); // "Bob"
```

### La división de una cadena en una matriz de cadenas en JavaScript se realiza mediante el método **split**:

```JavaScript
const nums = 'One,Two,Three';

nums.split(','); // ['One', 'Two', 'Three']
nums.split('One,'); // ['', 'Two,Three']
nums.split(',', 2); // ['One', 'Two']
nums.split('', 5); // ['O', 'n', 'e', ',', 'T']
```

Invertir una cadena usando **split**:

```JavaScript
const str = 'Home';
const reverseStr = str.split('').reverse().join();
console.log(reverseStr); // "emoH"
```

Aquí, usando **split()**, primero dividimos la cadena en el delimitador '' en una matriz de cadenas, cada una de las cuales es un carácter separado. Después de eso, invertimos la matriz usando **reverse()**, y al final, usando **join()**, la convertimos nuevamente en una cadena.

### Métodos que se pueden utilizar para reemplazar _pattern_ por _replacement_ en una cadena:

- replace(pattern, replacement);
- replaceAll(pattern, replacement).

Para _pattern_ puedes usar una cadena o una expresión regular, y para _replacement_ puedes usar una cadena o una función.

```JavaScript
const nums = 'One, Two, Three, Two';
nums.replace('Two', 'Six'); // One, Six, Three, Two
nums.replaceAll('Two', 'Six'); // One, Six, Three, Six
```

En este ejemplo, utilizando el método **replace**, reemplazamos la subcadena _Two_ por _Six_ en _nums_. Para hacer esto, pasamos la cadena a reemplazar como primer argumento a **replace**. Y el segundo argumento es la cadena con la que debe ser reemplazado. Usando **replaceAll** reemplazamos todas las apariciones de _Two_ por _Six_.

Usando **replaceAll** para eliminar espacios de una cadena:

```JavaScript
const str = 'A B C';
const strWithoutSpaces = str.replaceAll(' ', '');

console.log(strWithoutSpaces); // ABC
```

Si necesita eliminar otro carácter de una cadena:

```JavaScript
'Football'.replaceAll('o', ''); // "Ftball"

```

Obtener un código de carácter de una tabla UTF-16 en JavaScript se realiza mediante el método **charCodeAt**:

```JavaScript
'@'.charCodeAt(); // 64
'@8'.charCodeAt(); // 64
'@8'.at(1).charCodeAt(); // 56
```

El método estático **String.fromCharCode()** le permite generar una cadena a partir de los códigos de caracteres numéricos especificados:

```JavaScript
String.fromCharCode(64); // "@"
String.fromCharCode(64, 56); // "@8"
```

JavaScript se basó originalmente en la codificación UTF-8, que proporcionaba 2 bytes por carácter. Pero luego esto resultó insuficiente para representar a todos los personajes. Por lo tanto, se utilizan 4 bytes para codificar algunos caracteres.

Para obtener códigos de caracteres de 4 bytes, debe utilizar **codePointAt()** en lugar de **charCodeAt()**. Además, para componer una cadena a partir de códigos dados, debes usar **String.fromCodePoint()** en lugar de **String.fromCharCode()**:

```JavaScript
String.fromCodePoint(128075, 44, 32, 66, 111, 98, 33); // "👋, Bob!"

```

El método **repeat** le permite crear una cadena que consta de un número específico de repeticiones de otra:

```JavaScript
'Bob! ' + 'Yes! '.repeat(3); // "Bob! Yes! Yes! Yes!"

```

Los métodos **padStart** y **padEnd** le permiten rellenar una cadena hasta una longitud específica con el texto especificado:

```JavaScript
'0312'.padStart(16, '*'); // "************0312"
'About JavaScript'.padEnd(20, '.'); // About JavaScript....
```

Los métodos **toLowerCase** y **toUpperCase** están diseñados para convertir caracteres de cadena a minúsculas y mayúsculas, respectivamente.

```JavaScript
let myString = "Welcome to itchief!";
let upperCaseString = myString.toUpperCase();
let lowerCaseString = myString.toLowerCase();

console.log(upperCaseString); // "WELCOME TO ITCHIEF!"
console.log(lowerCaseString); // "welcome to itchief!"
```

---

---

# ¿Qué es un condicional?

Las declaraciones condicionales le permiten omitir o ejecutar otras declaraciones según el valor de una expresión específica. Estas declaraciones son puntos de decisión en un programa y, a veces, también se denominan declaraciones "ramificadas".

Si imagina que un programa es una carretera y el intérprete de JavaScript es un viajero que camina por ella, entonces las declaraciones condicionales pueden considerarse como encrucijadas en las que el código del programa se bifurca en dos o más carreteras, y en dichas encrucijadas el intérprete debe elegir cuál camino a tomar a continuación.

## Declaración if/else

La declaración **if** es una declaración de control básica que permite al intérprete de JavaScript tomar decisiones o ejecutar declaraciones con mayor precisión en función de condiciones. La declaración **if** tiene dos formas. Primero:

```JavaScript
if (expresión)
   operador
```

De esta forma, primero se evalúa la expresión. Si el resultado obtenido es verdadero, entonces se ejecuta la declaración. Si la expresión devuelve falso, entonces la declaración no se ejecuta. Por ejemplo:

```JavaScript
if (username == null)	// Si la variable username es null o undefined
   username = "Alex"; // definirlo
```

Tenga en cuenta que los paréntesis alrededor de la expresión condicional son una parte obligatoria de la sintaxis de la declaración **if**.

La segunda forma de la declaración **if** introduce una cláusula **else** que se ejecuta cuando la expresión se evalúa como falsa. Su sintaxis es:

```JavaScript
if (expresión)
   operador1
else
   operador2
```

Este formulario ejecuta _operador1_ si la expresión devuelve verdadero y _operador2_ si la expresión devuelve falso. Por ejemplo:

```JavaScript
if (n == 1)
   console.log("n = 1");
else
   console.log("n != 1);
```

## declaración else if

La declaración **if/else** evalúa el valor de una expresión y ejecuta uno u otro fragmento de código de programa, dependiendo del resultado. Pero ¿qué pasa si necesitas ejecutar uno de muchos fragmentos? Una forma posible de hacer esto es utilizar una declaración **else if**. Formalmente, no es un operador de JavaScript independiente; Este es solo un estilo de programación común que utiliza una declaración **if/else** repetida:

```JavaScript
if (n == 1) {
    // block 1
}
else if (n == 2) {
    // block 2
}
else if (n == 3) {
    // block 3
}
else {
    // block 4
}
```

No hay nada especial en esta pieza. Es simplemente una secuencia de declaraciones **if**, donde cada declaración **if** es parte de la cláusula else de la declaración anterior.

## Operador de switch

Una declaración **if** crea una bifurcación en el flujo del programa, y se pueden implementar bifurcaciones de múltiples estados usando múltiples declaraciones **else if**. Sin embargo, esta no siempre es la mejor solución, especialmente si todas las ramas dependen del valor de la misma expresión. En este caso, es un desperdicio volver a evaluar el valor de la misma expresión en múltiples declaraciones **if**.

La declaración de **switch** está diseñada precisamente para este tipo de situaciones. La palabra clave **switch** va seguida de una expresión entre paréntesis y un bloque de código entre llaves:

```JavaScript
switch(expresión) {
   instrucciones
}
```

Sin embargo, la sintaxis completa de la declaración **switch** es más compleja de lo que se muestra aquí. Varios lugares de un bloque están marcados con la palabra clave **case** seguida de una expresión y dos puntos.

Cuando se ejecuta una instrucción **switch**, evalúa el valor de la expresión y luego busca una etiqueta **case** que coincida con ese valor (la coincidencia se determina utilizando el operador de identidad ===). Si se encuentra la etiqueta, se ejecuta el bloque de código, comenzando con la primera declaración que sigue a la etiqueta **case**. Si no se encuentra una etiqueta **case** con un valor coincidente, la ejecución comienza con la primera declaración después de la etiqueta especial **default:**. Si falta la etiqueta **default:**, se omite todo el bloque de instrucción **switch**.

El funcionamiento del operador del **switch** es difícil de explicar con palabras; una explicación con un ejemplo parece mucho más clara. La siguiente declaración **switch** es equivalente a las declaraciones repetidas **if/else** que se muestran en el ejemplo anterior:

```JavaScript
switch(n) {
    case 1:        // if n === 1
         // run block 1
         break;    // break
    case 2:        // if n === 2
         // run block 2
         break;    // break
    case 3:        // if n === 3
         // run block 3
         break;    // break
    default:       // if else
         // run block 4
         break;    // break
}
```

Tenga en cuenta la palabra clave **break** al final de cada bloque **case**. La declaración **break** hace que el control se transfiera al final de la declaración **switch** y continúa la ejecución de las siguientes declaraciones. Las construcciones **case** en una declaración **switch** especifican sólo el punto inicial del código del programa que se ejecutará, pero no especifican ningún punto final.

Si no hay declaraciones de **break**, la declaración **switch** comenzará a ejecutar el bloque de código con la etiqueta **case** correspondiente al valor de la expresión y continuará ejecutando las declaraciones hasta llegar al final del bloque. En casos raros, esto es útil para escribir código que va de una etiqueta de **case** a la siguiente, pero en el 99% de los casos debes finalizar cuidadosamente cada bloque de **case** con una declaración de **break**. (Cuando use **switch** dentro de una función, puede usar una declaración **return** en lugar de **break**. Ambas declaraciones sirven para terminar la declaración **switch** y evitar que pase a la siguiente etiqueta de **case**.)

A continuación se muestra un ejemplo más práctico del uso del operador **switch**, que convierte un valor en una cadena de una manera que depende del tipo de valor:

```JavaScript
function convert(x) {
	switch(typeof x)
	{
		// Convertir número a entero hexadecimal
		case 'number':
			return x.toString(16);
		// Devuelve una cadena entre comillas
		case 'string':
			return '"' + x + '"';
		// Cualquier otro tipo se convierte como de costumbre
		default:
			return x.toString();
	}
}

console.log(convert(1067));     // output "42b"
```

Tenga en cuenta que en los dos ejemplos anteriores, las palabras clave **case** iban seguidas de números o cadenas literales. Así es como se usa con mayor frecuencia en la práctica la declaración **switch**, pero el estándar ECMAScript le permite especificar expresiones arbitrarias después de mayúsculas y minúsculas.

El operador **switch** primero evalúa la expresión después de la palabra clave **switch**, luego la expresión **case** en el orden en que se especifican, hasta que se encuentra un valor coincidente. El hecho de una coincidencia se determina utilizando el operador de identidad === en lugar del operador de igualdad ==, por lo que las expresiones deben coincidir sin ninguna conversión de tipo.

Debido a que no todas las expresiones de caso se evalúan cada vez que se ejecuta una instrucción de cambio, debe evitar el uso de expresiones de caso que tengan efectos secundarios como llamadas a funciones y asignaciones. Es más seguro limitar las expresiones "caso" a expresiones constantes.

Como se explicó anteriormente, si ninguna expresión **case** coincide con una expresión **switch**, la instrucción **switch** comienza a ejecutar la instrucción etiquetada **default:**. Si falta la etiqueta **default:**, el cuerpo de la instrucción **switch** se omite por completo. Tenga en cuenta que en los ejemplos anteriores, la etiqueta **default:** se incluye al final del cuerpo de la instrucción **switch**, después de todas las etiquetas **case**. Este es un lugar lógico y común para esto, pero de hecho puede ubicarse en cualquier lugar dentro de una declaración de **switch**.

---

---

# ¿Qué es un operador ternario?

El operador ternario **?:** es el único operador ternario (con tres operandos) en JavaScript. Este operador suele escribirse como **?:**, aunque tiene un aspecto diferente en los programas. Tiene tres operandos, el primero delante del carácter **?**, el segundo entre el carácter **?** y **:**, el tercero - después de **:**. Se utiliza de la siguiente manera:

```JavaScript
var n = 10;

// Determinar si el número es par o impar
var result = (n % 2 == 0) ? "incluso" : "extraño";

console.log(result);     // output "incluso"
```

Los operandos de un operador condicional pueden ser de cualquier tipo. El primer operando se evalúa y se utiliza como valor booleano. Si el primer operando se evalúa como verdadero, entonces se evalúa y devuelve el valor de la expresión en el segundo operando. Si el primer operando se evalúa como falso, entonces se evalúa y devuelve el valor de la expresión en el tercer operando. Siempre se calcula sólo un operando, el segundo o el tercero, y nunca ambos.

Se puede lograr el mismo resultado usando la declaración **if**, pero la declaración **?:** suele ser un atajo conveniente. El siguiente es un ejemplo típico que verifica si una variable está definida (y tiene un valor verdadero), y si es así, entonces se toma su valor, y si no, se toma el valor predeterminado:

```JavaScript
var message = 'Hello ' + (username ? username : 'friend');
```

Esta prueba es equivalente a la siguiente declaración **if**, pero más compacta:

```JavaScript
var message = 'Hello ';

if (username)
{
  message += username;
}
else
{
  message += 'friend';
}
```

---

---

# ¿Cuál es la diferencia entre una declaración de función y una expresión de función?

Hay dos formas de crear una función en JavaScript: una expresión de función y una declaración de función.

Las declaraciones de funciones se utilizaron durante mucho tiempo, pero fueron reemplazadas gradualmente por expresiones de funciones. Existen varias diferencias clave entre expresiones de funciones y declaraciones de funciones.

```JavaScript
function funcDeclaration() {
  return 'A function declaration';
}

let funcExpression = function () {
  return 'A function expression';
}
```

## ¿Qué es una declaración de función?

Una declaración de función es cuando creas una función y le das un nombre. Declaras el nombre de una función cuando escribes la palabra clave **fuction** seguida del nombre de la función. Por ejemplo:

```JavaScript
function myFunction() {
  // do something
};
```

Como puede ver, el nombre de la función (myFunction) se declara cuando se crea la función. Esto significa que puede llamar a una función antes de que esté definida.

Ejemplo de declaración de función:

```JavaScript
function add (a, b) {
  return a + b;
};
```

## ¿Qué es una expresión de función?

Las expresiones de función ocurren cuando creas una función y la asignas a una variable. La función es anónima, lo que significa que no tiene nombre. Por ejemplo:

```JavaScript
let myFunction = function() {
  // do something
};
```

Como puede ver, la función está asignada a la variable myFunction. Esto significa que debe definir una función antes de poder llamarla.

Ejemplo de expresión de función:

```JavaScript
let add = function (a, b) {
  return a + b;
};
```

## Diferencias entre una expresión de función y una declaración

Existen varias diferencias clave entre expresiones de función y declaraciones de función:

- Las declaraciones de funciones son elevadas, pero las expresiones de funciones no. Esto significa que puede llamar a una función antes de que esté definida, pero no puede hacerlo con una expresión de función.

- Con las expresiones de función, puede utilizar la función tan pronto como esté definida. Al declarar una función, debe esperar hasta que se haya analizado todo el script.

- Las expresiones de funciones se pueden utilizar como argumento para otra función, pero las declaraciones de funciones no.

- Las expresiones de funciones pueden ser anónimas, pero las declaraciones de funciones no.

- JavaScript: ¿Qué es el alojamiento?

## Comprender el alcance en una expresión de función: diferencias en el levantamiento de Javascript

Al igual que con la declaración let, las declaraciones de funciones se generan encima del código principal.

Las expresiones de funciones no se elevan. Esto les permite mantener una copia de las variables locales del ámbito en el que fueron definidas.

Normalmente, puede utilizar declaraciones de funciones y expresiones de funciones indistintamente. Pero hay ocasiones en las que las expresiones de función dan como resultado un código más fácil de entender sin la necesidad de un nombre de función temporal.

## Cómo elegir entre una expresión y una declaración

Entonces, ¿cuándo debería utilizar expresiones de función y cuándo debería utilizar declaraciones de función?

La respuesta depende de tus necesidades. Si necesita una función más flexible o una función que no se eleve, entonces una expresión de función es el camino a seguir. Si necesita una función más legible y comprensible, utilice una declaración de función.

Como habrás notado, las dos sintaxis son similares. La diferencia más obvia es que las expresiones de funciones son anónimas, mientras que las declaraciones de funciones tienen nombre.

Normalmente se utiliza una declaración de función cuando se necesita algo que las expresiones de función no pueden hacer. Si no necesita hacer nada que solo se pueda hacer con una declaración de función, entonces es mejor usar una expresión de función.

Utilice declaraciones de funciones cuando necesite crear una función recursiva o cuando necesite llamar una función antes de definirla. Utilice expresiones de función para obtener un código más limpio cuando no necesite hacer ninguna de estas cosas.

## Beneficios de las declaraciones de funciones

Hay varios beneficios clave al declarar funciones.

- Esto puede hacer que el código sea más legible. Si tiene una función larga, darle un nombre puede ayudar a realizar un seguimiento de lo que hace.
- Las declaraciones de funciones se elevan, lo que significa que están disponibles antes de que se definan en su código. Esto ayuda si necesita utilizar una función antes de definirla.

## Beneficios de las expresiones de funciones

Las expresiones de funciones también tienen sus ventajas.

- Son más flexibles que las declaraciones de funciones. Puede crear expresiones de funciones y asignarlas a diferentes variables, lo que puede resultar útil cuando necesita utilizar la misma función en diferentes lugares.
- Las expresiones de función no se elevan, por lo que no puede usarlas antes de que estén definidas en su código. Esto ayuda si desea asegurarse de que una función solo se utilice después de haber sido definida.

## Cuándo elegir una declaración de función o expresión de función

En la mayoría de los casos, es fácil determinar qué método de definir una función es mejor para sus necesidades. Estas pautas le ayudarán a tomar una decisión rápida en la mayoría de las situaciones.

### Utilice declaraciones de funciones cuando:

- necesita una función más legible y comprensible (por ejemplo, una función larga o una que necesitará usar en diferentes lugares);
- Una función anónima no le conviene;
- necesitas crear una función recursiva;
- es necesario llamar a la función antes de definirla.

### Utilice expresiones de función cuando:

- necesitas una función más flexible;
- necesitas una función que no se levante;
- una función sólo debe usarse cuando está definida;
- la función es anónima o no necesita nombre para su uso posterior;
- desea controlar cuándo se ejecuta una función utilizando técnicas como funciones invocadas inmediatamente (IIFE);
- desea pasar una función como argumento a otra función.

Sin embargo, hay varios casos en los que la flexibilidad de las expresiones de funciones se convierte en una poderosa ventaja.

## Expresión de función revelada: diferencias de elevación de Javascript

Hay varias formas diferentes en las que las expresiones de funciones se vuelven más útiles que las declaraciones de funciones.

- Cierres
- Argumentos a favor de otras funciones
- Expresión de función invocada inmediatamente (IIFE)

### Crear un cierre con expresiones de función

Los cierres se utilizan cuando desea pasar parámetros a una función antes de que se ejecute la función. Un buen ejemplo de cómo esto puede ayudarle es recorrer NodeLest.

Un cierre le permite conservar otra información, como un índice, en situaciones en las que esa información no está disponible después de ejecutar la función.

```Javascript
function tabsHandler(index) {
    return function tabClickEvent(evt) {
        // Do stuff with tab.
        // The index variable can be accessed from within here.
    };
}

let tabs = document.querySelectorAll('.tab'),
    i;

for (i = 0; i &lt; tabs.length; i += 1) {
    tabs[i].onclick = tabsHandler(i);
}
```

Los controladores de eventos adjuntos se ejecutan más tarde (una vez que se completa el ciclo), por lo que se necesita un cierre para almacenar el valor correspondiente del ciclo for.

```Javascript
// Bad code, demonstrating why a closure is needed
let i;

for (i = 0; i &lt; list.length; i += 1) {
    document.querySelector('#item' + i).onclick = function doSomething(evt) {
        // Do something with item i
        // But, by the time this function executes, the value of i is always list.length
    }
}
```

Es más fácil entender por qué ocurre el problema si extraes la función doSomething del bucle for.

```Javascript
// Bad code, demonstrating why a closure is needed

let list = document.querySelectorAll('.item'),
    i,
    doSomething = function (evt) {
        // Do something with item i.
        // But, by the time this function executes, the value of i is not what it was in the loop.
    };

for (i = 0; i &lt; list.length; i += 1) {
    item[i].onclick = doSomething;
}
```

La solución es pasar el índice como argumento a la función externa para que pueda pasar ese valor a la función interna. A menudo verá funciones de controlador utilizadas para organizar la información que necesita una función de retorno interna.

```Javascript
// The following is good code, demonstrating the use of a closure

let list = ['item1', 'item2', 'item3'],
    i,
    doSomethingHandler = function (itemIndex) {
        return function doSomething(evt) {
            // now this doSomething function can retain knowledge of
            // the index variable via the itemIndex parameter,
            // along with other variables that may be available too.
            console.log('Doing something with ' + list[itemIndex]);
        };
    };

for (i = 0; i &lt; list.length; i += 1) {
    list[i].onclick = doSomethingHandler(i);
}
```

### Pasar una expresión de función como argumento

Las expresiones de funciones se pueden pasar directamente a funciones sin la necesidad de una asignación de variable temporal intermedia.

La mayoría de las veces las verás como funciones anónimas. Aquí hay un ejemplo familiar de una expresión de función jQuery:

```Javascript
$(document).ready(function () {
    console.log('An anonymous function');
});
```

También se utiliza una expresión de función para procesar elementos de matriz cuando se utiliza un método como forEach().

No deberían ser funciones anónimas sin nombre. Es una buena idea darle un nombre a la expresión de la función, esto ayudará a expresar para qué sirve la función y ayudará con la depuración:

```Javascript
let productIds = ['12356', '13771', '15492'];

productIds.forEach(function showProduct(productId) {
    ...
});
```

## Expresiones de funciones invocadas inmediatamente (IIFE)

Los IIFE ayudan a evitar que sus funciones y variables afecten el alcance global.

Todas las propiedades incluidas están dentro del alcance de la función anónima. Este es un patrón de diseño común para evitar que aparezcan efectos secundarios inesperados y no deseados en su código.

También se utilizan como plantilla de módulo para colocar códigos de bloque en secciones que sean fáciles de mantener.

Ejemplo simple de IIFE:

```Javascript
(function () {
    // code in here
}());
```

...que, cuando se utiliza como módulo, puede facilitar el mantenimiento del código.

```Javascript
let myModule = (function () {
    let privateMethod = function () {
        console.log('A private method');
    },
    someMethod = function () {
        console.log('A public method');
    },
    anotherMethod = function () {
        console.log('Another public method');
    };

    return {
        someMethod: someMethod,
        anotherMethod: anotherMethod
    };
}());
```

---

---

# ¿Qué es la palabra clave "this" en JS?

Es "eso", pero lo que significa exactamente depende del contexto.

La palabra clave **this** es una de las características de JavaScript. Originariamente surgió de Java para ayudar a implementar la programación orientada a objetos. Y la peculiaridad es que esta palabra puede significar diferentes objetos dependiendo de dónde se escriba. Veamos cómo funciona usando ejemplos de código.

## Qué es this

En JavaScript, **this** es una referencia a algún objeto. La peculiaridad es que el objeto al que hace referencia **this** puede cambiar según el contexto de la llamada. Es como señalar con el dedo algo en el código y decir: "Aquí me refiero a este objeto". El truco es que **this** en el código puede ser diferente, y todo depende de quién quiera usar este objeto.

La mayoría de las veces, **this** lo determina quien llama a la función. Ésta es su diferencia con el alcance, que está determinado por el lugar donde se llama la función. Debido a esto, a menudo puedes encontrar muchas llamadas **this** en el código, pero se referirán a objetos diferentes.

Ahora veamos cómo cambia el valor de **this** en diferentes situaciones: desde una simple llamada sin contexto hasta funciones complejas.

## llamada sencilla

En general, **this** apunta a un objeto global. Para un navegador, dicho objeto es la propia ventana del navegador, por lo que si escribe en la consola del navegador

```Javascript
console.log(this);
```

luego veremos que aquí **this** está vinculado al contexto global, es decir, al objeto de ventana en el navegador.

```Javascript
Window {window: Window, self: Window, document: document, name: '', location: Location, …}
```

Cuando el modo estricto está habilitado en JS, las reglas cambian. Si la función se llama en modo **use strict**, entonces **this** será **undefined**.

## This se refiere a un objeto

Cuando **this** se usa dentro de un objeto, se refiere al objeto mismo. Digamos que creamos un objeto _dog_ con tres métodos y usamos **this** en uno de sus métodos. Dado que **this** dentro de un método apunta al objeto actual en cuyo contexto se llamó el método, en nuestro ejemplo obtendremos una referencia al objeto _dog_.

Escribamos un código simple con un objeto e imprimamos el valor de **this** en la consola:

```Javascript
var dog = {
  name: 'Cheems',
  breed: 'Shiba Inu',
  intro: function(){
    console.log(this);
  }
};

dog.intro();
```

En la consola veremos una representación del objeto con todos los métodos:

```Javascript
{name: 'Cheems', breed: 'Shiba Inu', intro: ƒ}
```

Usar **this** hace que el código sea más flexible. El valor de **this** está en sí mismo vinculado al objeto en cuyo contexto se llama. Esto permite que el método funcione con datos de una instancia específica de un objeto y haga que el código sea más universal.

## Modo de diseño

Un constructor es una función que se utiliza para crear objetos del mismo tipo. El nombre de un constructor en JavaScript debe ser un sustantivo y comenzar con letra mayúscula. Los constructores se llaman usando la palabra clave **new**. La tarea del diseñador es explicarle a la computadora qué parámetros y propiedades serán necesarios para crear un nuevo objeto.

Hagamos un constructor y creemos un nuevo objeto. Observe cómo usamos **this**: automáticamente apunta al objeto en el constructor actual desde donde se llama:

```Javascript
function Dog () {
// this está vinculado al nuevo objeto
  this.name = 'Cheems'
}

// crea un nuevo objeto Dog
const firstDog = new Dog()
firstDog.name === 'Cheems'

console.log(firstDog.name);
```

```Javascript
Cheems
```

Este enfoque es conveniente porque con la ayuda de **this** y una única función constructora podemos crear muchos objetos del mismo tipo e indicar directamente a qué objeto estamos accediendo.

Vamos a mostrar cómo funciona esto usando el ejemplo de una función constructora para crear objetos de automóvil:

```Javascript
function Car(brand, model, year) {

// используем this, чтобы установить свойства объектов
  this.brand = brand;
  this.model = model;
  this.year = year;
}

// создаём новые объекты с помощью функции-конструктора
const car1 = new Car('Toyota', 'Camry', 2022);
const car2 = new Car('Honda', 'Accord', 2021);
const car3 = new Car('Ford', 'Mustang', 2020);

console.log(car1);
console.log(car2);
console.log(car3);
```

```Javascript
Car {brand: 'Toyota', model: 'Camry', year: 2022}
Car {brand: 'Honda', model: 'Accord', year: 2021}
Car {brand: 'Ford', model: 'Mustang', year: 2020}
```

Si tuviéramos que escribir una lógica similar sin usar **this**, primero crearíamos un nuevo objeto, estableceríamos sus propiedades, devolveríamos el objeto y luego crearíamos otros nuevos. Entonces el código sería más engorroso.

## Trabajar con los métodos call() y apply()

En JS, los objetos suelen tener sus propias propiedades y métodos, y diferentes objetos no pueden simplemente usar los métodos de los demás. Pero a veces es necesario sortear esta limitación. Para hacer esto, use los métodos **call()** y **apply()**; le permiten llamar a las funciones necesarias en el contexto de otros objetos. Para pasar el contexto requerido a una función, se usa **this**: almacena el contexto de llamada, que no cambia cuando se pasa a otra función.

Llamar a una función a través de los métodos **call()** o **apply()** se denomina llamada indirecta.

Hay una ligera diferencia en la sintaxis de los métodos: **call()** toma una lista de argumentos separados por comas, **apply()** toma una serie de argumentos. Por lo demás, funcionan, más o menos, igual.

Para mayor claridad, hagamos esto:

1. Creemos una función que tome una palabra de saludo y un emoticón como argumento.
2. Dentro de esta función usamos **this**; esto nos ayudará a obtener el contexto del objeto que llamó a esta función.
3. Creemos dos variables con nombres.
4. Llamemos a la función de saludo usando variables con nombre como argumentos.
5. Como usamos **this** dentro de la función, obtendrá el contexto necesario: lo transferirá desde las variables nombradas.
6. Como resultado, la función de saludo de contexto entenderá que debemos tomar los nombres de las variables y agregarlos a la salida de la consola.

```Javascript
function greet(greetWord, emoticon) {
  console.log(`${greetWord} ${this.name} ${emoticon}`)
}

const user1 = { name: 'Barbie' }
const user2 = { name: 'Ken' }

greet.call(user1, 'Hi,', ':-)')
greet.call(user2, 'Hello,', ':-D')
greet.apply(user1, ['Hi,', ':-)'])
greet.apply(user2, ['Hello,', ':-D'])
```

```Javascript
Hi, Barbie :-)
Hello, Ken :-D
Hi, Barbie :-)
Hello, Ken :-D
```

## Funciones de flecha

Una función de flecha no crea su propio contexto de ejecución, sino que lo toma de su función externa en la que está definida esta función de flecha.

Creemos una función que imprima el saludo y el nombre de usuario, y luego repita el saludo después de un tiempo:

```Javascript
function greetWaitAndAgain() {
  console.log(`Hi, ${this.name}!`)
  setTimeout(() => {
    console.log(`Hi again, ${this.name}!`)
  })
}

// crear un objeto
const user = { name: 'Barbie' }

// agrega un método al objeto
user.greetWaitAndAgain = greetWaitAndAgain;
user.greetWaitAndAgain()
```

```Javascript
Hi, Barbie!
Hi again, Barbie!
```

Si usáramos una función normal, el contexto se perdería y **this** ya no apuntaría al objeto _user_, y entonces tendríamos que usar la exportación indirecta. Por esta razón, **this** se usa a menudo en funciones de flecha para evitar sobrecargar el código con métodos adicionales.

## Cómo entender cuál es el valor de this

Determinamos a qué es igual **this** en cada caso concreto:

- Si no estamos dentro de una función, entonces **this** es igual al objeto global: la ventana del navegador.
- Si una función se recibe como propiedad de un objeto y se usa inmediatamente, entonces **this** será igual a ese objeto.
- Si se llama a una función usando el operador **new**, entonces **this** se referirá al objeto recién creado en el constructor de la función.
- Si una función se crea usando el método **call\* o **apply**, entonces el valor de **this\*\* será el argumento de esa función.
- Si estamos dentro de una función de flecha, entonces **this** es igual al valor de **this** fuera de la función.
