# ¬øQu√© diferencia a Javascript de cualquier otro lenguaje de programaci√≥n?

**JavaScript** es un lenguaje de programaci√≥n utilizado principalmente en la web. Con su ayuda, los sitios web se vuelven interactivos: agregan ventanas emergentes, animaciones, botones y formularios para enviar informaci√≥n. Tambi√©n se le llama el idioma principal de la interfaz: el lado "frontal" del sitio con el que interact√∫an los usuarios.

**JavaScript** es similar a Java, Python, Go, C#, pero tiene sus propias caracter√≠sticas:

1. Interpretado, no compilado. Todos los lenguajes de programaci√≥n se dividen en dos grupos. El c√≥digo en lenguajes compilados debe ejecutarse primero a trav√©s de un programa especial, un compilador, y solo entonces se puede utilizar. La mayor√≠a de los lenguajes modernos est√°n compilados, a diferencia de **JavaScript**.

No es necesario compilar el c√≥digo en un lenguaje interpretado. Se escribe y se pasa inmediatamente al programa int√©rprete, que lo ejecuta inmediatamente. Esto acelera el desarrollo, pero requiere ejecutarse solo junto con el int√©rprete. Es cierto que el int√©rprete de **JavaScript** est√° integrado en todos los navegadores modernos, por lo que no hay problemas al ejecutar el c√≥digo.

2. Multiparadigma. Existen varios paradigmas en programaci√≥n:

- Objeto. En √©l se crean objetos para cada entidad del c√≥digo, por ejemplo un bot√≥n de pedido. Y luego se escriben las conexiones entre estos objetos.
- Funcional. Presta m√°s atenci√≥n a instrucciones espec√≠ficas. El bot√≥n aqu√≠ no es un objeto; en el c√≥digo se designa como el orden de las acciones que ocurren despu√©s de hacer clic.
- Imperativo. Aqu√≠ el c√≥digo se escribe como un conjunto claro de instrucciones que se ejecutan de forma estrictamente secuencial. Los paradigmas imperativo y funcional a menudo se utilizan juntos.

A menudo, los idiomas se centran en trabajar con un paradigma. **JavaScript** es diferente: no dicta c√≥mo se escribe el c√≥digo y le permite ce√±irse a diferentes estilos y t√©cnicas.

3. Sin tipificaci√≥n estricta. Existen lenguajes de programaci√≥n con tipado est√°tico. Si crea una variable, primero debe especificar su tipo, por ejemplo, un n√∫mero. Y en √©l no se puede almacenar nada m√°s que un n√∫mero.

**JavaScript** tiene escritura din√°mica: puedes poner cualquier cosa en una variable. Esto facilita la escritura de c√≥digo, pero puede provocar errores. Por ejemplo, **JavaScript** te permitir√° comparar una cadena con un n√∫mero e incluso producir alg√∫n tipo de resultado. ¬øQu√© es m√°s grande, "vaca" o "81"? **JavaScript** conoce la respuesta.

4. Integrado con HTML y CSS en navegadores. HTML y CSS son lenguajes de marcado para sitios web. No son lenguajes de programaci√≥n porque no te permiten escribir funciones ni procesar nada. Con su ayuda, configuran la apariencia del sitio: la ubicaci√≥n de los bloques, el tama√±o de fuente, los colores. Para hacer que un sitio web sea interactivo, necesita un lenguaje de programaci√≥n y **JavaScript** encaja perfectamente aqu√≠. Los navegadores modernos le permiten simplemente escribir c√≥digo **JavaScript** directamente en su formato HTML y CSS y funcionar√°.

A menudo, por conveniencia, los scripts se escriben en archivos separados y luego se inserta una referencia al archivo en el c√≥digo. Esto le permite evitar sobrecargar el c√≥digo en la p√°gina y utilizar los mismos scripts en diferentes lugares sin tener que reescribirlos.

5. Adecuado para backend. El c√≥digo **JavaScript** se puede ejecutar tanto en el navegador como en el servidor. Esto significa que puede usarlo para escribir no solo elementos interactivos de la p√°gina, sino tambi√©n la parte del servidor del sitio: procesamiento de datos y funciones de c√°lculo. Sin embargo, para ello es necesario dominar una herramienta independiente: Node.js. Este es un motor que le permite ejecutar JavaScript no en el navegador, sino en el servidor.

---

---

# ¬øCu√°les son algunos tipos de datos JS?

**JavaScript (JS)** es un lenguaje de programaci√≥n de **tipo din√°mico**. Esto significa que al declarar una variable, no es necesario especificar su tipo de datos; se determinar√° autom√°ticamente al asignar un valor.

Hay ocho tipos de datos en JS: number, string, boolean, undefined, object, bigInt, symbol y null.

## number

El tipo de datos **number** es num√©rico. Si escribe el valor de una variable como un n√∫mero, como en el c√≥digo siguiente, JS lo determinar√° autom√°ticamente como **number**:

```JavaScript
let age = 30;
```

Puedes realizar varias operaciones matem√°ticas con n√∫meros en JS: suma (+), resta (-), multiplicaci√≥n (\*) y divisi√≥n. Podr√≠a verse as√≠, por ejemplo:

```JavaScript
let quantity = 10;
let price = 2.99;
let total = quantity * price;
console.log(total); // 29.9
```

En el ejemplo anterior, a la variable "cantidad" se le asigna el valor 10 (un n√∫mero entero) y a la variable "precio" se le asigna el valor 2,99 (un n√∫mero de punto flotante). En la variable "total", el precio se multiplica por la cantidad y el resultado se env√≠a a la consola.

## string

El texto entre comillas simples (') o dobles (") se asigna autom√°ticamente al lenguaje de programaci√≥n como un tipo de datos **string**.

```JavaScript
let name = "Adam";
```

Es importante aclarar que las cadenas en JS son inmutables: no se puede reemplazar un car√°cter individual una vez creado. Puede realizar varias operaciones con cadenas ya preparadas, incluida su combinaci√≥n, como en el siguiente ejemplo:

```JavaScript
let firstName = "Adam";
let lastName = "Balkoev";
let fullName = firstName + " " + lastName;
// fullName will be "Adam Balkoev"
```

## boolean

El siguiente tipo de datos en JS es **boolean**. Este es un tipo booleano que s√≥lo puede tomar dos valores: **true** o **false**, verdadero o falso.

Por ejemplo, si creamos una variable _haveCar_ con el valor _true_, JS determinar√° autom√°ticamente que el tipo es **boolean**.

Este tipo de datos se utiliza a menudo en sentencias _if_ y bucles _for_ y le ayuda a comprender qu√© parte del c√≥digo ejecutar. Por ejemplo:

```JavaScript
let isTrue = true;
let isFalse = false;

if (isTrue) {
  console.log("The value is true");
} else {
  console.log("The value is false");
}
```

## null

**null** en JS es otro tipo de datos que tiene el significado de "nada" o "valor desconocido".

Creemos una variable papelera (papelera) con un valor vac√≠o, lo que indica que no sabemos qu√© hay en la papelera:

```JavaScript
let trash = null;
```

## undefined

Si crea una variable en JS y no le asigna ning√∫n valor, el lenguaje de programaci√≥n determinar√° autom√°ticamente el tipo de datos que contiene como **undefined**.

Veamos un ejemplo: cree una variable _box_ con un valor vac√≠o, lo que indica que todav√≠a no hay nada en el cuadro:

```JavaScript
let box;
condole.log(box) // undefined
```

## object

Veamos este tipo con un ejemplo. Escribamos un objeto _shop_, dentro del cual colocaremos varias propiedades: nombre, descripci√≥n y n√∫mero de departamentos.

```JavaScript
let shop = {
  title: "Goshan",
  description: "Some text",
  countShop: 10,
}
```

JS asignar√° autom√°ticamente el valor de esta variable al tipo **object**. Al determinar un tipo de datos, el lenguaje de programaci√≥n no comprueba lo que hay dentro del objeto: ve la estructura y la utiliza para determinar el tipo.

## bigInt

**BigInt** es un objeto integrado que proporciona una manera de representar n√∫meros enteros mayores que 2 53, que es el n√∫mero m√°s grande que JavaScript puede representar de manera confiable usando la primitiva N√∫mero.

```JavaScript
let bigInt = 19241924124n;
console.log(bigInt); // 19241924124n
console.log(typeof bigInt); // bigInt
```

## symbol

**symbol** es un tipo de datos especial. El prop√≥sito de los valores **symbol** es servir como nombres especiales para indicar propiedades especiales de los objetos.

```JavaScript
const sym1 = Symbol();
const sym2 = Symbol("foo");
const sym3 = Symbol("foo");
```

## Palabra clave typeof

El operador **typeof** le permite determinar qu√© tipo de datos se esconden detr√°s de una variable en particular.

Dado que JS asigna tipos de datos autom√°ticamente, a veces es √∫til saber c√≥mo ve el lenguaje el valor de una variable. Para ver el tipo de datos en la terminal, debe escribir una consola con una palabra clave y especificar una variable. Por ejemplo, as√≠:

```JavaScript
let name = "Adam";
console.log(typeof name); // string

let age = 30;
console.log(typeof age); // number
```

---

---

# ¬øCu√°les son las tres funciones de String en JS?

**String** es un tipo de datos de JavaScript para representar una secuencia arbitraria de caracteres.

JavaScript siempre usa codificaci√≥n **UTF-16** para cadenas. No depende de qu√© codificaci√≥n est√© configurada para la p√°gina HTML.

Crear una l√≠nea es muy sencillo. Para ello, solo necesitas colocar los s√≠mbolos necesarios entre:

- comillas simples ';
- doble comillas ";
- comillas invertidas `.

Por ejemplo:

```JavaScript
let name1 = 'Alexander';
let name2 = "Alexander";
let name3 = `Alexander`;
```

En el ejemplo anterior, tenemos tres filas asignadas a diferentes variables. Para asegurarnos de que sean todas cadenas, podemos verificar el tipo de variable:

```JavaScript
console.log(typeof(name1)); // string
console.log(typeof(name2)); // string
console.log(typeof(name3)); // String
```

Es importante saber que las cadenas en JavaScript son inmutables. Esto significa que una vez creada una cadena, su contenido no se puede cambiar. Para ello, simplemente necesitamos crear una nueva cadena y, por ejemplo, asignarla a la misma variable:

```JavaScript
let str = 'Go';
str = 'g' + str[1]; // "go"
console.log(str); // "go"
```

La cadena no puede contener ning√∫n car√°cter:

```JavaScript
const str1 = '';
const str2 = "";
const str3 = ``;
```

Estas l√≠neas se llaman vac√≠as.

## Concatenaci√≥n de cadenas

En JavaScript, la concatenaci√≥n (uni√≥n) de dos o m√°s cadenas en una se realiza mediante el operador +:

```JavaScript
const firstName = 'Marcus';
const lastName = 'Wolfe';
const fullName = firstName + ' ' + lastName;
console.log(fullName); // "Marcus Wolfe"
```

En este ejemplo, agregamos un espacio (' ') entre las cadenas contenidas en las variables _firstName_ y _lastName_.

Otra forma de concatenar cadenas en JavaScript es utilizar el m√©todo **concat()**:

```JavaScript
const firstName = 'Marcus';
const lastName = 'Wolfe';
const fullName = firstName.concat(' ', lastName);
console.log(fullName); // "Marcus Wolfe"
```

En JavaScript, tambi√©n puedes usar cadenas de plantilla para concatenar cadenas:

```JavaScript
const firstName = 'Marcus';
const lastName = 'Wolfe';
const fullName = `${firstName} ${lastName}`;
console.log(fullName); // "Marcus Wolfe"
```

## Cadenas de plantilla

Como se√±alamos anteriormente, las cadenas comod√≠n son una forma de crear cadenas usando comillas invertidas (`). Aparecieron en el lenguaje mucho m√°s tarde que las cadenas ordinarias y, a diferencia de ellas, tienen una serie de caracter√≠sticas adicionales.

```JavaScript
const mySkill = `* HTML
* CSS
* JavaScript`;
```

Para crear cadenas de varias l√≠neas utilizando comillas simples y dobles, debe utilizar el car√°cter de nueva l√≠nea (\n):

```JavaScript
const mySkill = '* HTML\n* CSS\n* JavaScript';
```

Puede colocar dicha cadena en varias l√≠neas solo usando el operador +:

```JavaScript
const mySkill = '* HTML\n' +
'* CSS\n' +
'* JavaScript';
```

Otra diferencia con la cadena de plantilla es que puede incluir expresiones ${...}:

```JavaScript
const name = 'Alexander';
const greeting = `Hi, ${name.toUpperCase()}.`; // "Hi, ALEXANDER."
```

## Personajes que escapan

En JavaScript, incluir un car√°cter en una cadena que se utiliza para crearla se realiza mediante escape. La barra invertida \ se utiliza como car√°cter de escape:

```JavaScript
const str1 = "He said, \"I love JavaScript!\""; // He said, "I love JavaScript!"
const str2 = 'It\'s a lovely day'; // It's a lovely day
const str3 = `$ echo \`hello\``; // $ echo `hello`
```

Si no se hace esto, se arrojar√° un error:

```JavaScript
str = "He said, "I learned from itchief!""; // Uncaught SyntaxError: Unexpected identifier 'I'
```

Adem√°s de escapar, en este caso simplemente puedes usar otra cita:

```JavaScript
const str1 = 'He said, "I love JavaScript!"'; // He said, "I love JavaScript!"
const str2 = `It's a lovely day`; // It's a lovely day
const str3 = "$ echo `hello`"; // $ echo `hello`
```

Adem√°s, el car√°cter de escape tambi√©n se utiliza para insertar caracteres especiales en el texto. Por ejemplo:

- \n - avance de l√≠nea;
- \ - barra invertida;
- \t es un car√°cter de tabulaci√≥n.

## Longitud de la cuerda

Obtener la longitud de una cuerda, es decir la cantidad de caracteres que lo componen se realiza en JavaScript usando la propiedad **lenght**:

```JavaScript
const mystr = 'My string';
// get length
const len = mystr.length;
console.log(len); // 9
```

## Acceso a los s√≠mbolos

Puede extraer un car√°cter espec√≠fico de una cadena usando corchetes. Dentro de los corchetes debes colocar un n√∫mero (el n√∫mero de serie del personaje). El conteo de caracteres en una l√≠nea comienza desde 0:

```JavaScript
const str = 'Welcome';
// get first symbol
console.log(str[0]); // "W"
// get second symbol
console.log(str[1]); // "e"
// get last symbol
console.log(str[str.length - 1]); // "e"
```

Al pasar el √≠ndice de un s√≠mbolo inexistente, obtenemos _undefined_:

```JavaScript
const name = 'Zoe';
console.log(str[-1]); // undefined
console.log(str[3]); // undefined
```

Adem√°s, puede obtener un car√°cter de cadena por su n√∫mero de serie utilizando m√©todos especiales dise√±ados para este caso: **charAt** y **at**.

```JavaScript
const str = 'Welcome';
console.log(str.charAt[2]); // "l"
console.log(str.at[3]); // "c"
```

El m√©todo **at** apareci√≥ en el lenguaje m√°s tarde y, a diferencia de **chartAt**, es m√°s flexible. Si se le pasa un n√∫mero negativo como entrada, entonces el car√°cter en este caso se contar√° desde el final de la l√≠nea.

```JavaScript
const fruit = 'Banana';
console.log(fruit.at[-1]); // "a"
console.log(fruit.at[-2]); // "n"
```

Tambi√©n puedes hacer esto usando **slice**:

```JavaScript
const str = 'Welcome';
console.log(str.slice(2, 0)); // "l"
console.log(str.slice(3, 0)); // "c"
```

Si necesita iterar a trav√©s de una cadena car√°cter por car√°cter, puede usar bucles. Por ejemplo, **for** o **for...of**:

```JavaScript
const name = 'Tess';
const len = name.length;
// for
for (let i = 0; i < len; i++) {
  console.log(name[i]); // "T", "e", "s", "s"
}
// for..of
for (let char of name) {
  console.log(char); // "T", "e", "s", "s"
}
```

## M√©todos de cadenas

Aunque las cadenas son un tipo de datos primitivo, se comportan como objetos en JavaScript. Por lo tanto, al trabajar con ellos, tenemos a nuestra disposici√≥n varias propiedades y m√©todos. Por ejemplo:

```JavaScript
// length
'Hello'.length; // 5
// concat
'Hello'.concat(', Alexander'); // "Hello, Alexander"
```

¬øC√≥mo funciona esto en JavaScript? Aqu√≠ todo es muy sencillo. Cuando se accede a una propiedad o m√©todo, la cadena se envuelve en un contenedor especial _new String()_. Esto crea una nueva instancia de la clase String, que a su vez tiene acceso a estas propiedades y m√©todos. Es decir, en esencia, el motor JavaScript internamente hace algo como lo siguiente:

```JavaScript
// type 'Hello'
typeof 'Hello'; // "string"
// type new String('Hello')
typeof new String('Hello'); // "object"

(new String('Hello')).length; // 5
(new String('Hello')).concat(', Alexander'); // "Hello, Alexander"
```

Pero no es necesario utilizar _new String()_ directamente para crear cadenas en JavaScript. Se utiliza, como se√±alamos anteriormente, de forma autom√°tica, como envoltorio sobre una cadena para que podamos trabajar con ella como con un objeto.

La funci√≥n _Sring_ en s√≠ sin _new_ se puede utilizar cuando necesites convertir alg√∫n valor a una cadena:

```J
String(5); // "5"
String(true); // "true"
```

Otra forma de convertir un valor en una cadena es utilizar el m√©todo **toString()**:

```J
(5).toString(); // "5"
true.toString(); // "true"
```

**String** contiene muchos m√©todos para realizar diversas operaciones en cadenas. Ya hemos comentado algunos de ellos anteriormente. Estos son: **concat()**, **at()**, **slice()** y otros. Ahora veamos qu√© otros m√©todos interesantes est√°n disponibles en **String** para trabajar con cadenas.

### M√©todos para encontrar una subcadena en una cadena:

- **indexOf(substring [, start])** ‚Äì devuelve el √≠ndice desde el cual comienza la subcadena buscada en la cadena;
- **lastIndexOf(substring, [, start])** es lo mismo que indexOf, solo que la b√∫squeda se realiza desde el final de la cadena.

```JavaScript
const vegetables = 'Tomato, Potato, Carrot, Tomato';
vegetables.indexOf('Tomato', 5); // 24

const fruits = 'Banana, Peach, Pear, Peach';
fruits.lastIndexOf('Peach', 10); // 8
```

El par√°metro _start_ es opcional. Se utiliza cuando necesita especificar desde qu√© car√°cter de una cadena desea comenzar la b√∫squeda. Si no lo pasas al m√©todo, la b√∫squeda se realizar√° desde el principio de la l√≠nea.

```JavaScript
const vegetables = 'Tomato, Potato, Carrot, Tomato';
vegetables.indexOf('Tomato'); // 0

const fruits = 'Banana, Peach, Pear, Peach';
fruits.lastIndexOf('Peach'); // 21
```

Si no se encuentra la subcadena especificada, estos m√©todos devuelven -1 como resultado.

```JavaScript
const vegetables = 'Tomato, Potato, Carrot, Tomato';
vegetables.indexOf('Broccoli'); // -1

const fruits = 'Banana, Peach, Pear, Peach';
fruits.lastIndexOf('Peach', 5); // -1
```

En el caso de que necesite verificar si la cadena especificada contiene lo que est√° buscando, simplemente puede usar el m√©todo **includes**:

```JavaScript
const vegetables = 'Tomato, Potato, Carrot, Tomato';
vegetables.includes('Carrot'); // true

// indexOf
vegetables.indexOf('Carrot') > -1; // true
```

Este m√©todo devuelve _true_ si se encuentra la cadena de b√∫squeda. De lo contrario, _false_.

Para buscar desde una posici√≥n espec√≠fica, s√≥lo necesitas pasarla al segundo argumento **includes**:

```JavaScript
const file = 'index.html';
file.includes('.html', file.length - 5); // true
```

Puede comprobar la coherencia del principio y el final de una cadena en JavaScript muy f√°cilmente utilizando los m√©todos especiales **startWith** y **EndsWith**:

```JavaScript
const href = 'https://itchief.ru/javascript/';
href.startsWith('https://itchief.ru'); // true

const file = 'index.html';
file.endsWith('.html'); // true
```

### M√©todos para obtener una subcadena:

**substring(start [, end])** ‚Äì parte de la cadena entre **start** y **end** (sin incluir);
**substr(start [, length])** ‚Äì parte de la cadena que comienza en el √≠ndice **start** con longitud **lengh**;
**slice(start [, end])** ‚Äì parte de la cadena entre **start** y **end** (sin incluir);

Ejemplos de uso del m√©todo **substring**:

```JavaScript
const greeting = 'Hello, Bob! How are you?';
// si no se especifica el segundo argumento, hasta el final de la l√≠nea
greeting.substring(7); // "Bob! How are you?"
greeting.substring(7, 10); // "Bob"
// si el inicio es mayor que el final, funcionar√° igual que si se intercambiaran los argumentos
greeting.substring(10, 7); // "Bob"
// si los argumentos son iguales, obtenemos una cadena vac√≠a
greeting.substring(7, 7); // ""
// los argumentos negativos se interpretan como 0
greeting.substring(5, -2); // "Hello"
```

Ejemplos de uso del m√©todo **substr**:

```JavaScript
const greeting = 'Hello, Bob! How are you?';
greeting.substr(7); // "Bob! How are you?"
greeting.substr(7, 3); // "Bob"
greeting.substr(-17, 3); // "Bob"
```

Ejemplos de uso del m√©todo **slice**:

```JavaScript
const greeting = 'Hello, Bob! How are you?';

greeting.slice(7); // "Bob! How are you?"
greeting.slice(7, 10); // "Bob"
greeting.slice(10, 7); // ""
greeting.slice(-17, -14); // "Bob"
```

### La divisi√≥n de una cadena en una matriz de cadenas en JavaScript se realiza mediante el m√©todo **split**:

```JavaScript
const nums = 'One,Two,Three';

nums.split(','); // ['One', 'Two', 'Three']
nums.split('One,'); // ['', 'Two,Three']
nums.split(',', 2); // ['One', 'Two']
nums.split('', 5); // ['O', 'n', 'e', ',', 'T']
```

Invertir una cadena usando **split**:

```JavaScript
const str = 'Home';
const reverseStr = str.split('').reverse().join();
console.log(reverseStr); // "emoH"
```

Aqu√≠, usando **split()**, primero dividimos la cadena en el delimitador '' en una matriz de cadenas, cada una de las cuales es un car√°cter separado. Despu√©s de eso, invertimos la matriz usando **reverse()**, y al final, usando **join()**, la convertimos nuevamente en una cadena.

### M√©todos que se pueden utilizar para reemplazar _pattern_ por _replacement_ en una cadena:

- replace(pattern, replacement);
- replaceAll(pattern, replacement).

Para _pattern_ puedes usar una cadena o una expresi√≥n regular, y para _replacement_ puedes usar una cadena o una funci√≥n.

```JavaScript
const nums = 'One, Two, Three, Two';
nums.replace('Two', 'Six'); // One, Six, Three, Two
nums.replaceAll('Two', 'Six'); // One, Six, Three, Six
```

En este ejemplo, utilizando el m√©todo **replace**, reemplazamos la subcadena _Two_ por _Six_ en _nums_. Para hacer esto, pasamos la cadena a reemplazar como primer argumento a **replace**. Y el segundo argumento es la cadena con la que debe ser reemplazado. Usando **replaceAll** reemplazamos todas las apariciones de _Two_ por _Six_.

Usando **replaceAll** para eliminar espacios de una cadena:

```JavaScript
const str = 'A B C';
const strWithoutSpaces = str.replaceAll(' ', '');

console.log(strWithoutSpaces); // ABC
```

Si necesita eliminar otro car√°cter de una cadena:

```JavaScript
'Football'.replaceAll('o', ''); // "Ftball"

```

Obtener un c√≥digo de car√°cter de una tabla UTF-16 en JavaScript se realiza mediante el m√©todo **charCodeAt**:

```JavaScript
'@'.charCodeAt(); // 64
'@8'.charCodeAt(); // 64
'@8'.at(1).charCodeAt(); // 56
```

El m√©todo est√°tico **String.fromCharCode()** le permite generar una cadena a partir de los c√≥digos de caracteres num√©ricos especificados:

```JavaScript
String.fromCharCode(64); // "@"
String.fromCharCode(64, 56); // "@8"
```

JavaScript se bas√≥ originalmente en la codificaci√≥n UTF-8, que proporcionaba 2 bytes por car√°cter. Pero luego esto result√≥ insuficiente para representar a todos los personajes. Por lo tanto, se utilizan 4 bytes para codificar algunos caracteres.

Para obtener c√≥digos de caracteres de 4 bytes, debe utilizar **codePointAt()** en lugar de **charCodeAt()**. Adem√°s, para componer una cadena a partir de c√≥digos dados, debes usar **String.fromCodePoint()** en lugar de **String.fromCharCode()**:

```JavaScript
String.fromCodePoint(128075, 44, 32, 66, 111, 98, 33); // "üëã, Bob!"

```

El m√©todo **repeat** le permite crear una cadena que consta de un n√∫mero espec√≠fico de repeticiones de otra:

```JavaScript
'Bob! ' + 'Yes! '.repeat(3); // "Bob! Yes! Yes! Yes!"

```

Los m√©todos **padStart** y **padEnd** le permiten rellenar una cadena hasta una longitud espec√≠fica con el texto especificado:

```JavaScript
'0312'.padStart(16, '*'); // "************0312"
'About JavaScript'.padEnd(20, '.'); // About JavaScript....
```

Los m√©todos **toLowerCase** y **toUpperCase** est√°n dise√±ados para convertir caracteres de cadena a min√∫sculas y may√∫sculas, respectivamente.

```JavaScript
let myString = "Welcome to itchief!";
let upperCaseString = myString.toUpperCase();
let lowerCaseString = myString.toLowerCase();

console.log(upperCaseString); // "WELCOME TO ITCHIEF!"
console.log(lowerCaseString); // "welcome to itchief!"
```

---

---

# ¬øQu√© es un condicional?

Las declaraciones condicionales le permiten omitir o ejecutar otras declaraciones seg√∫n el valor de una expresi√≥n espec√≠fica. Estas declaraciones son puntos de decisi√≥n en un programa y, a veces, tambi√©n se denominan declaraciones "ramificadas".

Si imagina que un programa es una carretera y el int√©rprete de JavaScript es un viajero que camina por ella, entonces las declaraciones condicionales pueden considerarse como encrucijadas en las que el c√≥digo del programa se bifurca en dos o m√°s carreteras, y en dichas encrucijadas el int√©rprete debe elegir cu√°l camino a tomar a continuaci√≥n.

## Declaraci√≥n if/else

La declaraci√≥n **if** es una declaraci√≥n de control b√°sica que permite al int√©rprete de JavaScript tomar decisiones o ejecutar declaraciones con mayor precisi√≥n en funci√≥n de condiciones. La declaraci√≥n **if** tiene dos formas. Primero:

```JavaScript
if (expresi√≥n)
   operador
```

De esta forma, primero se eval√∫a la expresi√≥n. Si el resultado obtenido es verdadero, entonces se ejecuta la declaraci√≥n. Si la expresi√≥n devuelve falso, entonces la declaraci√≥n no se ejecuta. Por ejemplo:

```JavaScript
if (username == null)	// Si la variable username es null o undefined
   username = "Alex"; // definirlo
```

Tenga en cuenta que los par√©ntesis alrededor de la expresi√≥n condicional son una parte obligatoria de la sintaxis de la declaraci√≥n **if**.

La segunda forma de la declaraci√≥n **if** introduce una cl√°usula **else** que se ejecuta cuando la expresi√≥n se eval√∫a como falsa. Su sintaxis es:

```JavaScript
if (expresi√≥n)
   operador1
else
   operador2
```

Este formulario ejecuta _operador1_ si la expresi√≥n devuelve verdadero y _operador2_ si la expresi√≥n devuelve falso. Por ejemplo:

```JavaScript
if (n == 1)
   console.log("n = 1");
else
   console.log("n != 1);
```

## declaraci√≥n else if

La declaraci√≥n **if/else** eval√∫a el valor de una expresi√≥n y ejecuta uno u otro fragmento de c√≥digo de programa, dependiendo del resultado. Pero ¬øqu√© pasa si necesitas ejecutar uno de muchos fragmentos? Una forma posible de hacer esto es utilizar una declaraci√≥n **else if**. Formalmente, no es un operador de JavaScript independiente; Este es solo un estilo de programaci√≥n com√∫n que utiliza una declaraci√≥n **if/else** repetida:

```JavaScript
if (n == 1) {
    // block 1
}
else if (n == 2) {
    // block 2
}
else if (n == 3) {
    // block 3
}
else {
    // block 4
}
```

No hay nada especial en esta pieza. Es simplemente una secuencia de declaraciones **if**, donde cada declaraci√≥n **if** es parte de la cl√°usula else de la declaraci√≥n anterior.

## Operador de switch

Una declaraci√≥n **if** crea una bifurcaci√≥n en el flujo del programa, y se pueden implementar bifurcaciones de m√∫ltiples estados usando m√∫ltiples declaraciones **else if**. Sin embargo, esta no siempre es la mejor soluci√≥n, especialmente si todas las ramas dependen del valor de la misma expresi√≥n. En este caso, es un desperdicio volver a evaluar el valor de la misma expresi√≥n en m√∫ltiples declaraciones **if**.

La declaraci√≥n de **switch** est√° dise√±ada precisamente para este tipo de situaciones. La palabra clave **switch** va seguida de una expresi√≥n entre par√©ntesis y un bloque de c√≥digo entre llaves:

```JavaScript
switch(expresi√≥n) {
   instrucciones
}
```

Sin embargo, la sintaxis completa de la declaraci√≥n **switch** es m√°s compleja de lo que se muestra aqu√≠. Varios lugares de un bloque est√°n marcados con la palabra clave **case** seguida de una expresi√≥n y dos puntos.

Cuando se ejecuta una instrucci√≥n **switch**, eval√∫a el valor de la expresi√≥n y luego busca una etiqueta **case** que coincida con ese valor (la coincidencia se determina utilizando el operador de identidad ===). Si se encuentra la etiqueta, se ejecuta el bloque de c√≥digo, comenzando con la primera declaraci√≥n que sigue a la etiqueta **case**. Si no se encuentra una etiqueta **case** con un valor coincidente, la ejecuci√≥n comienza con la primera declaraci√≥n despu√©s de la etiqueta especial **default:**. Si falta la etiqueta **default:**, se omite todo el bloque de instrucci√≥n **switch**.

El funcionamiento del operador del **switch** es dif√≠cil de explicar con palabras; una explicaci√≥n con un ejemplo parece mucho m√°s clara. La siguiente declaraci√≥n **switch** es equivalente a las declaraciones repetidas **if/else** que se muestran en el ejemplo anterior:

```JavaScript
switch(n) {
    case 1:        // if n === 1
         // run block 1
         break;    // break
    case 2:        // if n === 2
         // run block 2
         break;    // break
    case 3:        // if n === 3
         // run block 3
         break;    // break
    default:       // if else
         // run block 4
         break;    // break
}
```

Tenga en cuenta la palabra clave **break** al final de cada bloque **case**. La declaraci√≥n **break** hace que el control se transfiera al final de la declaraci√≥n **switch** y contin√∫a la ejecuci√≥n de las siguientes declaraciones. Las construcciones **case** en una declaraci√≥n **switch** especifican s√≥lo el punto inicial del c√≥digo del programa que se ejecutar√°, pero no especifican ning√∫n punto final.

Si no hay declaraciones de **break**, la declaraci√≥n **switch** comenzar√° a ejecutar el bloque de c√≥digo con la etiqueta **case** correspondiente al valor de la expresi√≥n y continuar√° ejecutando las declaraciones hasta llegar al final del bloque. En casos raros, esto es √∫til para escribir c√≥digo que va de una etiqueta de **case** a la siguiente, pero en el 99% de los casos debes finalizar cuidadosamente cada bloque de **case** con una declaraci√≥n de **break**. (Cuando use **switch** dentro de una funci√≥n, puede usar una declaraci√≥n **return** en lugar de **break**. Ambas declaraciones sirven para terminar la declaraci√≥n **switch** y evitar que pase a la siguiente etiqueta de **case**.)

A continuaci√≥n se muestra un ejemplo m√°s pr√°ctico del uso del operador **switch**, que convierte un valor en una cadena de una manera que depende del tipo de valor:

```JavaScript
function convert(x) {
	switch(typeof x)
	{
		// Convertir n√∫mero a entero hexadecimal
		case 'number':
			return x.toString(16);
		// Devuelve una cadena entre comillas
		case 'string':
			return '"' + x + '"';
		// Cualquier otro tipo se convierte como de costumbre
		default:
			return x.toString();
	}
}

console.log(convert(1067));     // output "42b"
```

Tenga en cuenta que en los dos ejemplos anteriores, las palabras clave **case** iban seguidas de n√∫meros o cadenas literales. As√≠ es como se usa con mayor frecuencia en la pr√°ctica la declaraci√≥n **switch**, pero el est√°ndar ECMAScript le permite especificar expresiones arbitrarias despu√©s de may√∫sculas y min√∫sculas.

El operador **switch** primero eval√∫a la expresi√≥n despu√©s de la palabra clave **switch**, luego la expresi√≥n **case** en el orden en que se especifican, hasta que se encuentra un valor coincidente. El hecho de una coincidencia se determina utilizando el operador de identidad === en lugar del operador de igualdad ==, por lo que las expresiones deben coincidir sin ninguna conversi√≥n de tipo.

Debido a que no todas las expresiones de caso se eval√∫an cada vez que se ejecuta una instrucci√≥n de cambio, debe evitar el uso de expresiones de caso que tengan efectos secundarios como llamadas a funciones y asignaciones. Es m√°s seguro limitar las expresiones "caso" a expresiones constantes.

Como se explic√≥ anteriormente, si ninguna expresi√≥n **case** coincide con una expresi√≥n **switch**, la instrucci√≥n **switch** comienza a ejecutar la instrucci√≥n etiquetada **default:**. Si falta la etiqueta **default:**, el cuerpo de la instrucci√≥n **switch** se omite por completo. Tenga en cuenta que en los ejemplos anteriores, la etiqueta **default:** se incluye al final del cuerpo de la instrucci√≥n **switch**, despu√©s de todas las etiquetas **case**. Este es un lugar l√≥gico y com√∫n para esto, pero de hecho puede ubicarse en cualquier lugar dentro de una declaraci√≥n de **switch**.

---

---

# ¬øQu√© es un operador ternario?

El operador ternario **?:** es el √∫nico operador ternario (con tres operandos) en JavaScript. Este operador suele escribirse como **?:**, aunque tiene un aspecto diferente en los programas. Tiene tres operandos, el primero delante del car√°cter **?**, el segundo entre el car√°cter **?** y **:**, el tercero - despu√©s de **:**. Se utiliza de la siguiente manera:

```JavaScript
var n = 10;

// Determinar si el n√∫mero es par o impar
var result = (n % 2 == 0) ? "incluso" : "extra√±o";

console.log(result);     // output "incluso"
```

Los operandos de un operador condicional pueden ser de cualquier tipo. El primer operando se eval√∫a y se utiliza como valor booleano. Si el primer operando se eval√∫a como verdadero, entonces se eval√∫a y devuelve el valor de la expresi√≥n en el segundo operando. Si el primer operando se eval√∫a como falso, entonces se eval√∫a y devuelve el valor de la expresi√≥n en el tercer operando. Siempre se calcula s√≥lo un operando, el segundo o el tercero, y nunca ambos.

Se puede lograr el mismo resultado usando la declaraci√≥n **if**, pero la declaraci√≥n **?:** suele ser un atajo conveniente. El siguiente es un ejemplo t√≠pico que verifica si una variable est√° definida (y tiene un valor verdadero), y si es as√≠, entonces se toma su valor, y si no, se toma el valor predeterminado:

```JavaScript
var message = 'Hello ' + (username ? username : 'friend');
```

Esta prueba es equivalente a la siguiente declaraci√≥n **if**, pero m√°s compacta:

```JavaScript
var message = 'Hello ';

if (username)
{
  message += username;
}
else
{
  message += 'friend';
}
```

---

---

# ¬øCu√°l es la diferencia entre una declaraci√≥n de funci√≥n y una expresi√≥n de funci√≥n?

Hay dos formas de crear una funci√≥n en JavaScript: una expresi√≥n de funci√≥n y una declaraci√≥n de funci√≥n.

Las declaraciones de funciones se utilizaron durante mucho tiempo, pero fueron reemplazadas gradualmente por expresiones de funciones. Existen varias diferencias clave entre expresiones de funciones y declaraciones de funciones.

```JavaScript
function funcDeclaration() {
  return 'A function declaration';
}

let funcExpression = function () {
  return 'A function expression';
}
```

## ¬øQu√© es una declaraci√≥n de funci√≥n?

Una declaraci√≥n de funci√≥n es cuando creas una funci√≥n y le das un nombre. Declaras el nombre de una funci√≥n cuando escribes la palabra clave **fuction** seguida del nombre de la funci√≥n. Por ejemplo:

```JavaScript
function myFunction() {
  // do something
};
```

Como puede ver, el nombre de la funci√≥n (myFunction) se declara cuando se crea la funci√≥n. Esto significa que puede llamar a una funci√≥n antes de que est√© definida.

Ejemplo de declaraci√≥n de funci√≥n:

```JavaScript
function add (a, b) {
  return a + b;
};
```

## ¬øQu√© es una expresi√≥n de funci√≥n?

Las expresiones de funci√≥n ocurren cuando creas una funci√≥n y la asignas a una variable. La funci√≥n es an√≥nima, lo que significa que no tiene nombre. Por ejemplo:

```JavaScript
let myFunction = function() {
  // do something
};
```

Como puede ver, la funci√≥n est√° asignada a la variable myFunction. Esto significa que debe definir una funci√≥n antes de poder llamarla.

Ejemplo de expresi√≥n de funci√≥n:

```JavaScript
let add = function (a, b) {
  return a + b;
};
```

## Diferencias entre una expresi√≥n de funci√≥n y una declaraci√≥n

Existen varias diferencias clave entre expresiones de funci√≥n y declaraciones de funci√≥n:

- Las declaraciones de funciones son elevadas, pero las expresiones de funciones no. Esto significa que puede llamar a una funci√≥n antes de que est√© definida, pero no puede hacerlo con una expresi√≥n de funci√≥n.

- Con las expresiones de funci√≥n, puede utilizar la funci√≥n tan pronto como est√© definida. Al declarar una funci√≥n, debe esperar hasta que se haya analizado todo el script.

- Las expresiones de funciones se pueden utilizar como argumento para otra funci√≥n, pero las declaraciones de funciones no.

- Las expresiones de funciones pueden ser an√≥nimas, pero las declaraciones de funciones no.

- JavaScript: ¬øQu√© es el alojamiento?

## Comprender el alcance en una expresi√≥n de funci√≥n: diferencias en el levantamiento de Javascript

Al igual que con la declaraci√≥n let, las declaraciones de funciones se generan encima del c√≥digo principal.

Las expresiones de funciones no se elevan. Esto les permite mantener una copia de las variables locales del √°mbito en el que fueron definidas.

Normalmente, puede utilizar declaraciones de funciones y expresiones de funciones indistintamente. Pero hay ocasiones en las que las expresiones de funci√≥n dan como resultado un c√≥digo m√°s f√°cil de entender sin la necesidad de un nombre de funci√≥n temporal.

## C√≥mo elegir entre una expresi√≥n y una declaraci√≥n

Entonces, ¬øcu√°ndo deber√≠a utilizar expresiones de funci√≥n y cu√°ndo deber√≠a utilizar declaraciones de funci√≥n?

La respuesta depende de tus necesidades. Si necesita una funci√≥n m√°s flexible o una funci√≥n que no se eleve, entonces una expresi√≥n de funci√≥n es el camino a seguir. Si necesita una funci√≥n m√°s legible y comprensible, utilice una declaraci√≥n de funci√≥n.

Como habr√°s notado, las dos sintaxis son similares. La diferencia m√°s obvia es que las expresiones de funciones son an√≥nimas, mientras que las declaraciones de funciones tienen nombre.

Normalmente se utiliza una declaraci√≥n de funci√≥n cuando se necesita algo que las expresiones de funci√≥n no pueden hacer. Si no necesita hacer nada que solo se pueda hacer con una declaraci√≥n de funci√≥n, entonces es mejor usar una expresi√≥n de funci√≥n.

Utilice declaraciones de funciones cuando necesite crear una funci√≥n recursiva o cuando necesite llamar una funci√≥n antes de definirla. Utilice expresiones de funci√≥n para obtener un c√≥digo m√°s limpio cuando no necesite hacer ninguna de estas cosas.

## Beneficios de las declaraciones de funciones

Hay varios beneficios clave al declarar funciones.

- Esto puede hacer que el c√≥digo sea m√°s legible. Si tiene una funci√≥n larga, darle un nombre puede ayudar a realizar un seguimiento de lo que hace.
- Las declaraciones de funciones se elevan, lo que significa que est√°n disponibles antes de que se definan en su c√≥digo. Esto ayuda si necesita utilizar una funci√≥n antes de definirla.

## Beneficios de las expresiones de funciones

Las expresiones de funciones tambi√©n tienen sus ventajas.

- Son m√°s flexibles que las declaraciones de funciones. Puede crear expresiones de funciones y asignarlas a diferentes variables, lo que puede resultar √∫til cuando necesita utilizar la misma funci√≥n en diferentes lugares.
- Las expresiones de funci√≥n no se elevan, por lo que no puede usarlas antes de que est√©n definidas en su c√≥digo. Esto ayuda si desea asegurarse de que una funci√≥n solo se utilice despu√©s de haber sido definida.

## Cu√°ndo elegir una declaraci√≥n de funci√≥n o expresi√≥n de funci√≥n

En la mayor√≠a de los casos, es f√°cil determinar qu√© m√©todo de definir una funci√≥n es mejor para sus necesidades. Estas pautas le ayudar√°n a tomar una decisi√≥n r√°pida en la mayor√≠a de las situaciones.

### Utilice declaraciones de funciones cuando:

- necesita una funci√≥n m√°s legible y comprensible (por ejemplo, una funci√≥n larga o una que necesitar√° usar en diferentes lugares);
- Una funci√≥n an√≥nima no le conviene;
- necesitas crear una funci√≥n recursiva;
- es necesario llamar a la funci√≥n antes de definirla.

### Utilice expresiones de funci√≥n cuando:

- necesitas una funci√≥n m√°s flexible;
- necesitas una funci√≥n que no se levante;
- una funci√≥n s√≥lo debe usarse cuando est√° definida;
- la funci√≥n es an√≥nima o no necesita nombre para su uso posterior;
- desea controlar cu√°ndo se ejecuta una funci√≥n utilizando t√©cnicas como funciones invocadas inmediatamente (IIFE);
- desea pasar una funci√≥n como argumento a otra funci√≥n.

Sin embargo, hay varios casos en los que la flexibilidad de las expresiones de funciones se convierte en una poderosa ventaja.

## Expresi√≥n de funci√≥n revelada: diferencias de elevaci√≥n de Javascript

Hay varias formas diferentes en las que las expresiones de funciones se vuelven m√°s √∫tiles que las declaraciones de funciones.

- Cierres
- Argumentos a favor de otras funciones
- Expresi√≥n de funci√≥n invocada inmediatamente (IIFE)

### Crear un cierre con expresiones de funci√≥n

Los cierres se utilizan cuando desea pasar par√°metros a una funci√≥n antes de que se ejecute la funci√≥n. Un buen ejemplo de c√≥mo esto puede ayudarle es recorrer NodeLest.

Un cierre le permite conservar otra informaci√≥n, como un √≠ndice, en situaciones en las que esa informaci√≥n no est√° disponible despu√©s de ejecutar la funci√≥n.

```Javascript
function tabsHandler(index) {
    return function tabClickEvent(evt) {
        // Do stuff with tab.
        // The index variable can be accessed from within here.
    };
}

let tabs = document.querySelectorAll('.tab'),
    i;

for (i = 0; i &lt; tabs.length; i += 1) {
    tabs[i].onclick = tabsHandler(i);
}
```

Los controladores de eventos adjuntos se ejecutan m√°s tarde (una vez que se completa el ciclo), por lo que se necesita un cierre para almacenar el valor correspondiente del ciclo for.

```Javascript
// Bad code, demonstrating why a closure is needed
let i;

for (i = 0; i &lt; list.length; i += 1) {
    document.querySelector('#item' + i).onclick = function doSomething(evt) {
        // Do something with item i
        // But, by the time this function executes, the value of i is always list.length
    }
}
```

Es m√°s f√°cil entender por qu√© ocurre el problema si extraes la funci√≥n doSomething del bucle for.

```Javascript
// Bad code, demonstrating why a closure is needed

let list = document.querySelectorAll('.item'),
    i,
    doSomething = function (evt) {
        // Do something with item i.
        // But, by the time this function executes, the value of i is not what it was in the loop.
    };

for (i = 0; i &lt; list.length; i += 1) {
    item[i].onclick = doSomething;
}
```

La soluci√≥n es pasar el √≠ndice como argumento a la funci√≥n externa para que pueda pasar ese valor a la funci√≥n interna. A menudo ver√° funciones de controlador utilizadas para organizar la informaci√≥n que necesita una funci√≥n de retorno interna.

```Javascript
// The following is good code, demonstrating the use of a closure

let list = ['item1', 'item2', 'item3'],
    i,
    doSomethingHandler = function (itemIndex) {
        return function doSomething(evt) {
            // now this doSomething function can retain knowledge of
            // the index variable via the itemIndex parameter,
            // along with other variables that may be available too.
            console.log('Doing something with ' + list[itemIndex]);
        };
    };

for (i = 0; i &lt; list.length; i += 1) {
    list[i].onclick = doSomethingHandler(i);
}
```

### Pasar una expresi√≥n de funci√≥n como argumento

Las expresiones de funciones se pueden pasar directamente a funciones sin la necesidad de una asignaci√≥n de variable temporal intermedia.

La mayor√≠a de las veces las ver√°s como funciones an√≥nimas. Aqu√≠ hay un ejemplo familiar de una expresi√≥n de funci√≥n jQuery:

```Javascript
$(document).ready(function () {
    console.log('An anonymous function');
});
```

Tambi√©n se utiliza una expresi√≥n de funci√≥n para procesar elementos de matriz cuando se utiliza un m√©todo como forEach().

No deber√≠an ser funciones an√≥nimas sin nombre. Es una buena idea darle un nombre a la expresi√≥n de la funci√≥n, esto ayudar√° a expresar para qu√© sirve la funci√≥n y ayudar√° con la depuraci√≥n:

```Javascript
let productIds = ['12356', '13771', '15492'];

productIds.forEach(function showProduct(productId) {
    ...
});
```

## Expresiones de funciones invocadas inmediatamente (IIFE)

Los IIFE ayudan a evitar que sus funciones y variables afecten el alcance global.

Todas las propiedades incluidas est√°n dentro del alcance de la funci√≥n an√≥nima. Este es un patr√≥n de dise√±o com√∫n para evitar que aparezcan efectos secundarios inesperados y no deseados en su c√≥digo.

Tambi√©n se utilizan como plantilla de m√≥dulo para colocar c√≥digos de bloque en secciones que sean f√°ciles de mantener.

Ejemplo simple de IIFE:

```Javascript
(function () {
    // code in here
}());
```

...que, cuando se utiliza como m√≥dulo, puede facilitar el mantenimiento del c√≥digo.

```Javascript
let myModule = (function () {
    let privateMethod = function () {
        console.log('A private method');
    },
    someMethod = function () {
        console.log('A public method');
    },
    anotherMethod = function () {
        console.log('Another public method');
    };

    return {
        someMethod: someMethod,
        anotherMethod: anotherMethod
    };
}());
```

---

---

# ¬øQu√© es la palabra clave "this" en JS?

Es "eso", pero lo que significa exactamente depende del contexto.

La palabra clave **this** es una de las caracter√≠sticas de JavaScript. Originariamente surgi√≥ de Java para ayudar a implementar la programaci√≥n orientada a objetos. Y la peculiaridad es que esta palabra puede significar diferentes objetos dependiendo de d√≥nde se escriba. Veamos c√≥mo funciona usando ejemplos de c√≥digo.

## Qu√© es this

En JavaScript, **this** es una referencia a alg√∫n objeto. La peculiaridad es que el objeto al que hace referencia **this** puede cambiar seg√∫n el contexto de la llamada. Es como se√±alar con el dedo algo en el c√≥digo y decir: "Aqu√≠ me refiero a este objeto". El truco es que **this** en el c√≥digo puede ser diferente, y todo depende de qui√©n quiera usar este objeto.

La mayor√≠a de las veces, **this** lo determina quien llama a la funci√≥n. √âsta es su diferencia con el alcance, que est√° determinado por el lugar donde se llama la funci√≥n. Debido a esto, a menudo puedes encontrar muchas llamadas **this** en el c√≥digo, pero se referir√°n a objetos diferentes.

Ahora veamos c√≥mo cambia el valor de **this** en diferentes situaciones: desde una simple llamada sin contexto hasta funciones complejas.

## llamada sencilla

En general, **this** apunta a un objeto global. Para un navegador, dicho objeto es la propia ventana del navegador, por lo que si escribe en la consola del navegador

```Javascript
console.log(this);
```

luego veremos que aqu√≠ **this** est√° vinculado al contexto global, es decir, al objeto de ventana en el navegador.

```Javascript
Window¬†{window: Window, self: Window, document: document, name: '', location: Location,¬†‚Ä¶}
```

Cuando el modo estricto est√° habilitado en JS, las reglas cambian. Si la funci√≥n se llama en modo **use strict**, entonces **this** ser√° **undefined**.

## This se refiere a un objeto

Cuando **this** se usa dentro de un objeto, se refiere al objeto mismo. Digamos que creamos un objeto _dog_ con tres m√©todos y usamos **this** en uno de sus m√©todos. Dado que **this** dentro de un m√©todo apunta al objeto actual en cuyo contexto se llam√≥ el m√©todo, en nuestro ejemplo obtendremos una referencia al objeto _dog_.

Escribamos un c√≥digo simple con un objeto e imprimamos el valor de **this** en la consola:

```Javascript
var dog = {
  name: 'Cheems',
  breed: 'Shiba Inu',
  intro: function(){
    console.log(this);
  }
};

dog.intro();
```

En la consola veremos una representaci√≥n del objeto con todos los m√©todos:

```Javascript
{name: 'Cheems', breed: 'Shiba Inu', intro: ∆í}
```

Usar **this** hace que el c√≥digo sea m√°s flexible. El valor de **this** est√° en s√≠ mismo vinculado al objeto en cuyo contexto se llama. Esto permite que el m√©todo funcione con datos de una instancia espec√≠fica de un objeto y haga que el c√≥digo sea m√°s universal.

## Modo de dise√±o

Un constructor es una funci√≥n que se utiliza para crear objetos del mismo tipo. El nombre de un constructor en JavaScript debe ser un sustantivo y comenzar con letra may√∫scula. Los constructores se llaman usando la palabra clave **new**. La tarea del dise√±ador es explicarle a la computadora qu√© par√°metros y propiedades ser√°n necesarios para crear un nuevo objeto.

Hagamos un constructor y creemos un nuevo objeto. Observe c√≥mo usamos **this**: autom√°ticamente apunta al objeto en el constructor actual desde donde se llama:

```Javascript
function Dog () {
// this est√° vinculado al nuevo objeto
  this.name = 'Cheems'
}

// crea un nuevo objeto Dog
const firstDog = new Dog()
firstDog.name === 'Cheems'

console.log(firstDog.name);
```

```Javascript
Cheems
```

Este enfoque es conveniente porque con la ayuda de **this** y una √∫nica funci√≥n constructora podemos crear muchos objetos del mismo tipo e indicar directamente a qu√© objeto estamos accediendo.

Vamos a mostrar c√≥mo funciona esto usando el ejemplo de una funci√≥n constructora para crear objetos de autom√≥vil:

```Javascript
function Car(brand, model, year) {

// –∏—Å–ø–æ–ª—å–∑—É–µ–º this, —á—Ç–æ–±—ã —É—Å—Ç–∞–Ω–æ–≤–∏—Ç—å —Å–≤–æ–π—Å—Ç–≤–∞ –æ–±—ä–µ–∫—Ç–æ–≤
  this.brand = brand;
  this.model = model;
  this.year = year;
}

// —Å–æ–∑–¥–∞—ë–º –Ω–æ–≤—ã–µ –æ–±—ä–µ–∫—Ç—ã —Å –ø–æ–º–æ—â—å—é —Ñ—É–Ω–∫—Ü–∏–∏-–∫–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä–∞
const car1 = new Car('Toyota', 'Camry', 2022);
const car2 = new Car('Honda', 'Accord', 2021);
const car3 = new Car('Ford', 'Mustang', 2020);

console.log(car1);
console.log(car2);
console.log(car3);
```

```Javascript
Car¬†{brand: 'Toyota', model: 'Camry', year: 2022}
Car¬†{brand: 'Honda', model: 'Accord', year: 2021}
Car¬†{brand: 'Ford', model: 'Mustang', year: 2020}
```

Si tuvi√©ramos que escribir una l√≥gica similar sin usar **this**, primero crear√≠amos un nuevo objeto, establecer√≠amos sus propiedades, devolver√≠amos el objeto y luego crear√≠amos otros nuevos. Entonces el c√≥digo ser√≠a m√°s engorroso.

## Trabajar con los m√©todos call() y apply()

En JS, los objetos suelen tener sus propias propiedades y m√©todos, y diferentes objetos no pueden simplemente usar los m√©todos de los dem√°s. Pero a veces es necesario sortear esta limitaci√≥n. Para hacer esto, use los m√©todos **call()** y **apply()**; le permiten llamar a las funciones necesarias en el contexto de otros objetos. Para pasar el contexto requerido a una funci√≥n, se usa **this**: almacena el contexto de llamada, que no cambia cuando se pasa a otra funci√≥n.

Llamar a una funci√≥n a trav√©s de los m√©todos **call()** o **apply()** se denomina llamada indirecta.

Hay una ligera diferencia en la sintaxis de los m√©todos: **call()** toma una lista de argumentos separados por comas, **apply()** toma una serie de argumentos. Por lo dem√°s, funcionan, m√°s o menos, igual.

Para mayor claridad, hagamos esto:

1. Creemos una funci√≥n que tome una palabra de saludo y un emotic√≥n como argumento.
2. Dentro de esta funci√≥n usamos **this**; esto nos ayudar√° a obtener el contexto del objeto que llam√≥ a esta funci√≥n.
3. Creemos dos variables con nombres.
4. Llamemos a la funci√≥n de saludo usando variables con nombre como argumentos.
5. Como usamos **this** dentro de la funci√≥n, obtendr√° el contexto necesario: lo transferir√° desde las variables nombradas.
6. Como resultado, la funci√≥n de saludo de contexto entender√° que debemos tomar los nombres de las variables y agregarlos a la salida de la consola.

```Javascript
function greet(greetWord, emoticon) {
  console.log(`${greetWord} ${this.name} ${emoticon}`)
}

const user1 = { name: 'Barbie' }
const user2 = { name: 'Ken' }

greet.call(user1, 'Hi,', ':-)')
greet.call(user2, 'Hello,', ':-D')
greet.apply(user1, ['Hi,', ':-)'])
greet.apply(user2, ['Hello,', ':-D'])
```

```Javascript
Hi, Barbie :-)
Hello, Ken :-D
Hi, Barbie :-)
Hello, Ken :-D
```

## Funciones de flecha

Una funci√≥n de flecha no crea su propio contexto de ejecuci√≥n, sino que lo toma de su funci√≥n externa en la que est√° definida esta funci√≥n de flecha.

Creemos una funci√≥n que imprima el saludo y el nombre de usuario, y luego repita el saludo despu√©s de un tiempo:

```Javascript
function greetWaitAndAgain() {
  console.log(`Hi, ${this.name}!`)
  setTimeout(() => {
    console.log(`Hi again, ${this.name}!`)
  })
}

// crear un objeto
const user = { name: 'Barbie' }

// agrega un m√©todo al objeto
user.greetWaitAndAgain = greetWaitAndAgain;
user.greetWaitAndAgain()
```

```Javascript
Hi, Barbie!
Hi again, Barbie!
```

Si us√°ramos una funci√≥n normal, el contexto se perder√≠a y **this** ya no apuntar√≠a al objeto _user_, y entonces tendr√≠amos que usar la exportaci√≥n indirecta. Por esta raz√≥n, **this** se usa a menudo en funciones de flecha para evitar sobrecargar el c√≥digo con m√©todos adicionales.

## C√≥mo entender cu√°l es el valor de this

Determinamos a qu√© es igual **this** en cada caso concreto:

- Si no estamos dentro de una funci√≥n, entonces **this** es igual al objeto global: la ventana del navegador.
- Si una funci√≥n se recibe como propiedad de un objeto y se usa inmediatamente, entonces **this** ser√° igual a ese objeto.
- Si se llama a una funci√≥n usando el operador **new**, entonces **this** se referir√° al objeto reci√©n creado en el constructor de la funci√≥n.
- Si una funci√≥n se crea usando el m√©todo **call\* o **apply**, entonces el valor de **this\*\* ser√° el argumento de esa funci√≥n.
- Si estamos dentro de una funci√≥n de flecha, entonces **this** es igual al valor de **this** fuera de la funci√≥n.
