# ¿Qué diferencia a Javascript de cualquier otro lenguaje de programación?

**JavaScript** es un lenguaje de programación utilizado principalmente en la web. Con su ayuda, los sitios web se vuelven interactivos: agregan ventanas emergentes, animaciones, botones y formularios para enviar información. También se le llama el idioma principal de la interfaz: el lado "frontal" del sitio con el que interactúan los usuarios.

**JavaScript** es similar a Java, Python, Go, C#, pero tiene sus propias características:

1. Interpretado, no compilado. Todos los lenguajes de programación se dividen en dos grupos. El código en lenguajes compilados debe ejecutarse primero a través de un programa especial, un compilador, y solo entonces se puede utilizar. La mayoría de los lenguajes modernos están compilados, a diferencia de **JavaScript**.

No es necesario compilar el código en un lenguaje interpretado. Se escribe y se pasa inmediatamente al programa intérprete, que lo ejecuta inmediatamente. Esto acelera el desarrollo, pero requiere ejecutarse solo junto con el intérprete. Es cierto que el intérprete de **JavaScript** está integrado en todos los navegadores modernos, por lo que no hay problemas al ejecutar el código.

2. Multiparadigma. Existen varios paradigmas en programación:

- Objeto. En él se crean objetos para cada entidad del código, por ejemplo un botón de pedido. Y luego se escriben las conexiones entre estos objetos.
- Funcional. Presta más atención a instrucciones específicas. El botón aquí no es un objeto; en el código se designa como el orden de las acciones que ocurren después de hacer clic.
- Imperativo. Aquí el código se escribe como un conjunto claro de instrucciones que se ejecutan de forma estrictamente secuencial. Los paradigmas imperativo y funcional a menudo se utilizan juntos.

A menudo, los idiomas se centran en trabajar con un paradigma. **JavaScript** es diferente: no dicta cómo se escribe el código y le permite ceñirse a diferentes estilos y técnicas.

3. Sin tipificación estricta. Existen lenguajes de programación con tipado estático. Si crea una variable, primero debe especificar su tipo, por ejemplo, un número. Y en él no se puede almacenar nada más que un número.

**JavaScript** tiene escritura dinámica: puedes poner cualquier cosa en una variable. Esto facilita la escritura de código, pero puede provocar errores. Por ejemplo, **JavaScript** te permitirá comparar una cadena con un número e incluso producir algún tipo de resultado. ¿Qué es más grande, "vaca" o "81"? **JavaScript** conoce la respuesta.

4. Integrado con HTML y CSS en navegadores. HTML y CSS son lenguajes de marcado para sitios web. No son lenguajes de programación porque no te permiten escribir funciones ni procesar nada. Con su ayuda, configuran la apariencia del sitio: la ubicación de los bloques, el tamaño de fuente, los colores. Para hacer que un sitio web sea interactivo, necesita un lenguaje de programación y **JavaScript** encaja perfectamente aquí. Los navegadores modernos le permiten simplemente escribir código **JavaScript** directamente en su formato HTML y CSS y funcionará.

A menudo, por conveniencia, los scripts se escriben en archivos separados y luego se inserta una referencia al archivo en el código. Esto le permite evitar sobrecargar el código en la página y utilizar los mismos scripts en diferentes lugares sin tener que reescribirlos.

5. Adecuado para backend. El código **JavaScript** se puede ejecutar tanto en el navegador como en el servidor. Esto significa que puede usarlo para escribir no solo elementos interactivos de la página, sino también la parte del servidor del sitio: procesamiento de datos y funciones de cálculo. Sin embargo, para ello es necesario dominar una herramienta independiente: Node.js. Este es un motor que le permite ejecutar JavaScript no en el navegador, sino en el servidor.

---

---

# ¿Cuáles son algunos tipos de datos JS?

**JavaScript (JS)** es un lenguaje de programación de **tipo dinámico**. Esto significa que al declarar una variable, no es necesario especificar su tipo de datos; se determinará automáticamente al asignar un valor.

Hay ocho tipos de datos en JS: number, string, boolean, undefined, object, bigInt, symbol y null.

## number

El tipo de datos **number** es numérico. Si escribe el valor de una variable como un número, como en el código siguiente, JS lo determinará automáticamente como **number**:

```JavaScript
let age = 30;
```

Puedes realizar varias operaciones matemáticas con números en JS: suma (+), resta (-), multiplicación (\*) y división. Podría verse así, por ejemplo:

```JavaScript
let quantity = 10;
let price = 2.99;
let total = quantity * price;
console.log(total); // 29.9
```

En el ejemplo anterior, a la variable "cantidad" se le asigna el valor 10 (un número entero) y a la variable "precio" se le asigna el valor 2,99 (un número de punto flotante). En la variable "total", el precio se multiplica por la cantidad y el resultado se envía a la consola.

## string

El texto entre comillas simples (') o dobles (") se asigna automáticamente al lenguaje de programación como un tipo de datos **string**.

```JavaScript
let name = "Adam";
```

Es importante aclarar que las cadenas en JS son inmutables: no se puede reemplazar un carácter individual una vez creado. Puede realizar varias operaciones con cadenas ya preparadas, incluida su combinación, como en el siguiente ejemplo:

```JavaScript
let firstName = "Adam";
let lastName = "Balkoev";
let fullName = firstName + " " + lastName;
// fullName will be "Adam Balkoev"
```

## boolean

El siguiente tipo de datos en JS es **boolean**. Este es un tipo booleano que sólo puede tomar dos valores: **true** o **false**, verdadero o falso.

Por ejemplo, si creamos una variable _haveCar_ con el valor _true_, JS determinará automáticamente que el tipo es **boolean**.

Este tipo de datos se utiliza a menudo en sentencias _if_ y bucles _for_ y le ayuda a comprender qué parte del código ejecutar. Por ejemplo:

```JavaScript
let isTrue = true;
let isFalse = false;

if (isTrue) {
  console.log("The value is true");
} else {
  console.log("The value is false");
}
```

## null

**null** en JS es otro tipo de datos que tiene el significado de "nada" o "valor desconocido".

Creemos una variable papelera (papelera) con un valor vacío, lo que indica que no sabemos qué hay en la papelera:

```JavaScript
let trash = null;
```

## undefined

Si crea una variable en JS y no le asigna ningún valor, el lenguaje de programación determinará automáticamente el tipo de datos que contiene como **undefined**.

Veamos un ejemplo: cree una variable _box_ con un valor vacío, lo que indica que todavía no hay nada en el cuadro:

```JavaScript
let box;
condole.log(box) // undefined
```

## object

Veamos este tipo con un ejemplo. Escribamos un objeto _shop_, dentro del cual colocaremos varias propiedades: nombre, descripción y número de departamentos.

```JavaScript
let shop = {
  title: "Goshan",
  description: "Some text",
  countShop: 10,
}
```

JS asignará automáticamente el valor de esta variable al tipo **object**. Al determinar un tipo de datos, el lenguaje de programación no comprueba lo que hay dentro del objeto: ve la estructura y la utiliza para determinar el tipo.

## bigInt

**BigInt** es un objeto integrado que proporciona una manera de representar números enteros mayores que 2 53, que es el número más grande que JavaScript puede representar de manera confiable usando la primitiva Número.

```JavaScript
let bigInt = 19241924124n;
console.log(bigInt); // 19241924124n
console.log(typeof bigInt); // bigInt
```

## symbol

**symbol** es un tipo de datos especial. El propósito de los valores **symbol** es servir como nombres especiales para indicar propiedades especiales de los objetos.

```JavaScript
const sym1 = Symbol();
const sym2 = Symbol("foo");
const sym3 = Symbol("foo");
```

## Palabra clave typeof

El operador **typeof** le permite determinar qué tipo de datos se esconden detrás de una variable en particular.

Dado que JS asigna tipos de datos automáticamente, a veces es útil saber cómo ve el lenguaje el valor de una variable. Para ver el tipo de datos en la terminal, debe escribir una consola con una palabra clave y especificar una variable. Por ejemplo, así:

```JavaScript
let name = "Adam";
console.log(typeof name); // string

let age = 30;
console.log(typeof age); // number
```

---

---

# ¿Qué es un condicional?

Las declaraciones condicionales le permiten omitir o ejecutar otras declaraciones según el valor de una expresión específica. Estas declaraciones son puntos de decisión en un programa y, a veces, también se denominan declaraciones "ramificadas".

Si imagina que un programa es una carretera y el intérprete de JavaScript es un viajero que camina por ella, entonces las declaraciones condicionales pueden considerarse como encrucijadas en las que el código del programa se bifurca en dos o más carreteras, y en dichas encrucijadas el intérprete debe elegir cuál camino a tomar a continuación.

## Declaración if/else

La declaración **if** es una declaración de control básica que permite al intérprete de JavaScript tomar decisiones o ejecutar declaraciones con mayor precisión en función de condiciones. La declaración **if** tiene dos formas. Primero:

```JavaScript
if (expresión)
   operador
```

De esta forma, primero se evalúa la expresión. Si el resultado obtenido es verdadero, entonces se ejecuta la declaración. Si la expresión devuelve falso, entonces la declaración no se ejecuta. Por ejemplo:

```JavaScript
if (username == null)	// Si la variable username es null o undefined
   username = "Alex"; // definirlo
```

Tenga en cuenta que los paréntesis alrededor de la expresión condicional son una parte obligatoria de la sintaxis de la declaración **if**.

La segunda forma de la declaración **if** introduce una cláusula **else** que se ejecuta cuando la expresión se evalúa como falsa. Su sintaxis es:

```JavaScript
if (expresión)
   operador1
else
   operador2
```

Este formulario ejecuta _operador1_ si la expresión devuelve verdadero y _operador2_ si la expresión devuelve falso. Por ejemplo:

```JavaScript
if (n == 1)
   console.log("n = 1");
else
   console.log("n != 1);
```

## declaración else if

La declaración **if/else** evalúa el valor de una expresión y ejecuta uno u otro fragmento de código de programa, dependiendo del resultado. Pero ¿qué pasa si necesitas ejecutar uno de muchos fragmentos? Una forma posible de hacer esto es utilizar una declaración **else if**. Formalmente, no es un operador de JavaScript independiente; Este es solo un estilo de programación común que utiliza una declaración **if/else** repetida:

```JavaScript
if (n == 1) {
    // block 1
}
else if (n == 2) {
    // block 2
}
else if (n == 3) {
    // block 3
}
else {
    // block 4
}
```

No hay nada especial en esta pieza. Es simplemente una secuencia de declaraciones **if**, donde cada declaración **if** es parte de la cláusula else de la declaración anterior.

## Operador de switch

Una declaración **if** crea una bifurcación en el flujo del programa, y se pueden implementar bifurcaciones de múltiples estados usando múltiples declaraciones **else if**. Sin embargo, esta no siempre es la mejor solución, especialmente si todas las ramas dependen del valor de la misma expresión. En este caso, es un desperdicio volver a evaluar el valor de la misma expresión en múltiples declaraciones **if**.

La declaración de **switch** está diseñada precisamente para este tipo de situaciones. La palabra clave **switch** va seguida de una expresión entre paréntesis y un bloque de código entre llaves:

```JavaScript
switch(expresión) {
   instrucciones
}
```

Sin embargo, la sintaxis completa de la declaración **switch** es más compleja de lo que se muestra aquí. Varios lugares de un bloque están marcados con la palabra clave **case** seguida de una expresión y dos puntos.

Cuando se ejecuta una instrucción **switch**, evalúa el valor de la expresión y luego busca una etiqueta **case** que coincida con ese valor (la coincidencia se determina utilizando el operador de identidad ===). Si se encuentra la etiqueta, se ejecuta el bloque de código, comenzando con la primera declaración que sigue a la etiqueta **case**. Si no se encuentra una etiqueta **case** con un valor coincidente, la ejecución comienza con la primera declaración después de la etiqueta especial **default:**. Si falta la etiqueta **default:**, se omite todo el bloque de instrucción **switch**.

El funcionamiento del operador del **switch** es difícil de explicar con palabras; una explicación con un ejemplo parece mucho más clara. La siguiente declaración **switch** es equivalente a las declaraciones repetidas **if/else** que se muestran en el ejemplo anterior:

```JavaScript
switch(n) {
    case 1:        // if n === 1
         // run block 1
         break;    // break
    case 2:        // if n === 2
         // run block 2
         break;    // break
    case 3:        // if n === 3
         // run block 3
         break;    // break
    default:       // if else
         // run block 4
         break;    // break
}
```

Tenga en cuenta la palabra clave **break** al final de cada bloque **case**. La declaración **break** hace que el control se transfiera al final de la declaración **switch** y continúa la ejecución de las siguientes declaraciones. Las construcciones **case** en una declaración **switch** especifican sólo el punto inicial del código del programa que se ejecutará, pero no especifican ningún punto final.

Si no hay declaraciones de **break**, la declaración **switch** comenzará a ejecutar el bloque de código con la etiqueta **case** correspondiente al valor de la expresión y continuará ejecutando las declaraciones hasta llegar al final del bloque. En casos raros, esto es útil para escribir código que va de una etiqueta de **case** a la siguiente, pero en el 99% de los casos debes finalizar cuidadosamente cada bloque de **case** con una declaración de **break**. (Cuando use **switch** dentro de una función, puede usar una declaración **return** en lugar de **break**. Ambas declaraciones sirven para terminar la declaración **switch** y evitar que pase a la siguiente etiqueta de **case**.)

A continuación se muestra un ejemplo más práctico del uso del operador **switch**, que convierte un valor en una cadena de una manera que depende del tipo de valor:

```JavaScript
function convert(x) {
	switch(typeof x)
	{
		// Convertir número a entero hexadecimal
		case 'number':
			return x.toString(16);
		// Devuelve una cadena entre comillas
		case 'string':
			return '"' + x + '"';
		// Cualquier otro tipo se convierte como de costumbre
		default:
			return x.toString();
	}
}

console.log(convert(1067));     // output "42b"
```

Tenga en cuenta que en los dos ejemplos anteriores, las palabras clave **case** iban seguidas de números o cadenas literales. Así es como se usa con mayor frecuencia en la práctica la declaración **switch**, pero el estándar ECMAScript le permite especificar expresiones arbitrarias después de mayúsculas y minúsculas.

El operador **switch** primero evalúa la expresión después de la palabra clave **switch**, luego la expresión **case** en el orden en que se especifican, hasta que se encuentra un valor coincidente. El hecho de una coincidencia se determina utilizando el operador de identidad === en lugar del operador de igualdad ==, por lo que las expresiones deben coincidir sin ninguna conversión de tipo.

Debido a que no todas las expresiones de caso se evalúan cada vez que se ejecuta una instrucción de cambio, debe evitar el uso de expresiones de caso que tengan efectos secundarios como llamadas a funciones y asignaciones. Es más seguro limitar las expresiones "caso" a expresiones constantes.

Como se explicó anteriormente, si ninguna expresión **case** coincide con una expresión **switch**, la instrucción **switch** comienza a ejecutar la instrucción etiquetada **default:**. Si falta la etiqueta **default:**, el cuerpo de la instrucción **switch** se omite por completo. Tenga en cuenta que en los ejemplos anteriores, la etiqueta **default:** se incluye al final del cuerpo de la instrucción **switch**, después de todas las etiquetas **case**. Este es un lugar lógico y común para esto, pero de hecho puede ubicarse en cualquier lugar dentro de una declaración de **switch**.

---

---

# ¿Qué es un operador ternario?

El operador ternario **?:** es el único operador ternario (con tres operandos) en JavaScript. Este operador suele escribirse como **?:**, aunque tiene un aspecto diferente en los programas. Tiene tres operandos, el primero delante del carácter **?**, el segundo entre el carácter **?** y **:**, el tercero - después de **:**. Se utiliza de la siguiente manera:

```JavaScript
var n = 10;

// Determinar si el número es par o impar
var result = (n % 2 == 0) ? "incluso" : "extraño";

console.log(result);     // output "incluso"
```

Los operandos de un operador condicional pueden ser de cualquier tipo. El primer operando se evalúa y se utiliza como valor booleano. Si el primer operando se evalúa como verdadero, entonces se evalúa y devuelve el valor de la expresión en el segundo operando. Si el primer operando se evalúa como falso, entonces se evalúa y devuelve el valor de la expresión en el tercer operando. Siempre se calcula sólo un operando, el segundo o el tercero, y nunca ambos.

Se puede lograr el mismo resultado usando la declaración **if**, pero la declaración **?:** suele ser un atajo conveniente. El siguiente es un ejemplo típico que verifica si una variable está definida (y tiene un valor verdadero), y si es así, entonces se toma su valor, y si no, se toma el valor predeterminado:

```JavaScript
var message = 'Hello ' + (username ? username : 'friend');
```

Esta prueba es equivalente a la siguiente declaración **if**, pero más compacta:

```JavaScript
var message = 'Hello ';

if (username)
{
  message += username;
}
else
{
  message += 'friend';
}
```

---

---

# ¿Cuál es la diferencia entre una declaración de función y una expresión de función?

Hay dos formas de crear una función en JavaScript: una expresión de función y una declaración de función.

Las declaraciones de funciones se utilizaron durante mucho tiempo, pero fueron reemplazadas gradualmente por expresiones de funciones. Existen varias diferencias clave entre expresiones de funciones y declaraciones de funciones.

```JavaScript
function funcDeclaration() {
  return 'A function declaration';
}

let funcExpression = function () {
  return 'A function expression';
}
```

## ¿Qué es una declaración de función?

Una declaración de función es cuando creas una función y le das un nombre. Declaras el nombre de una función cuando escribes la palabra clave **fuction** seguida del nombre de la función. Por ejemplo:

```JavaScript
function myFunction() {
  // do something
};
```

Como puede ver, el nombre de la función (myFunction) se declara cuando se crea la función. Esto significa que puede llamar a una función antes de que esté definida.

Ejemplo de declaración de función:

```JavaScript
function add (a, b) {
  return a + b;
};
```

## ¿Qué es una expresión de función?

Las expresiones de función ocurren cuando creas una función y la asignas a una variable. La función es anónima, lo que significa que no tiene nombre. Por ejemplo:

```JavaScript
let myFunction = function() {
  // do something
};
```

Como puede ver, la función está asignada a la variable myFunction. Esto significa que debe definir una función antes de poder llamarla.

Ejemplo de expresión de función:

```JavaScript
let add = function (a, b) {
  return a + b;
};
```

## Diferencias entre una expresión de función y una declaración

Existen varias diferencias clave entre expresiones de función y declaraciones de función:

- Las declaraciones de funciones son elevadas, pero las expresiones de funciones no. Esto significa que puede llamar a una función antes de que esté definida, pero no puede hacerlo con una expresión de función.

- Con las expresiones de función, puede utilizar la función tan pronto como esté definida. Al declarar una función, debe esperar hasta que se haya analizado todo el script.

- Las expresiones de funciones se pueden utilizar como argumento para otra función, pero las declaraciones de funciones no.

- Las expresiones de funciones pueden ser anónimas, pero las declaraciones de funciones no.

- JavaScript: ¿Qué es el alojamiento?

## Comprender el alcance en una expresión de función: diferencias en el levantamiento de Javascript

Al igual que con la declaración let, las declaraciones de funciones se generan encima del código principal.

Las expresiones de funciones no se elevan. Esto les permite mantener una copia de las variables locales del ámbito en el que fueron definidas.

Normalmente, puede utilizar declaraciones de funciones y expresiones de funciones indistintamente. Pero hay ocasiones en las que las expresiones de función dan como resultado un código más fácil de entender sin la necesidad de un nombre de función temporal.

## Cómo elegir entre una expresión y una declaración

Entonces, ¿cuándo debería utilizar expresiones de función y cuándo debería utilizar declaraciones de función?

La respuesta depende de tus necesidades. Si necesita una función más flexible o una función que no se eleve, entonces una expresión de función es el camino a seguir. Si necesita una función más legible y comprensible, utilice una declaración de función.

Como habrás notado, las dos sintaxis son similares. La diferencia más obvia es que las expresiones de funciones son anónimas, mientras que las declaraciones de funciones tienen nombre.

Normalmente se utiliza una declaración de función cuando se necesita algo que las expresiones de función no pueden hacer. Si no necesita hacer nada que solo se pueda hacer con una declaración de función, entonces es mejor usar una expresión de función.

Utilice declaraciones de funciones cuando necesite crear una función recursiva o cuando necesite llamar una función antes de definirla. Utilice expresiones de función para obtener un código más limpio cuando no necesite hacer ninguna de estas cosas.

## Beneficios de las declaraciones de funciones

Hay varios beneficios clave al declarar funciones.

- Esto puede hacer que el código sea más legible. Si tiene una función larga, darle un nombre puede ayudar a realizar un seguimiento de lo que hace.
- Las declaraciones de funciones se elevan, lo que significa que están disponibles antes de que se definan en su código. Esto ayuda si necesita utilizar una función antes de definirla.

## Beneficios de las expresiones de funciones

Las expresiones de funciones también tienen sus ventajas.

- Son más flexibles que las declaraciones de funciones. Puede crear expresiones de funciones y asignarlas a diferentes variables, lo que puede resultar útil cuando necesita utilizar la misma función en diferentes lugares.
- Las expresiones de función no se elevan, por lo que no puede usarlas antes de que estén definidas en su código. Esto ayuda si desea asegurarse de que una función solo se utilice después de haber sido definida.

## Cuándo elegir una declaración de función o expresión de función

En la mayoría de los casos, es fácil determinar qué método de definir una función es mejor para sus necesidades. Estas pautas le ayudarán a tomar una decisión rápida en la mayoría de las situaciones.

### Utilice declaraciones de funciones cuando:

- necesita una función más legible y comprensible (por ejemplo, una función larga o una que necesitará usar en diferentes lugares);
- Una función anónima no le conviene;
- necesitas crear una función recursiva;
- es necesario llamar a la función antes de definirla.

### Utilice expresiones de función cuando:

- necesitas una función más flexible;
- necesitas una función que no se levante;
- una función sólo debe usarse cuando está definida;
- la función es anónima o no necesita nombre para su uso posterior;
- desea controlar cuándo se ejecuta una función utilizando técnicas como funciones invocadas inmediatamente (IIFE);
- desea pasar una función como argumento a otra función.

Sin embargo, hay varios casos en los que la flexibilidad de las expresiones de funciones se convierte en una poderosa ventaja.

## Expresión de función revelada: diferencias de elevación de Javascript

Hay varias formas diferentes en las que las expresiones de funciones se vuelven más útiles que las declaraciones de funciones.

- Cierres
- Argumentos a favor de otras funciones
- Expresión de función invocada inmediatamente (IIFE)

### Crear un cierre con expresiones de función

Los cierres se utilizan cuando desea pasar parámetros a una función antes de que se ejecute la función. Un buen ejemplo de cómo esto puede ayudarle es recorrer NodeLest.

Un cierre le permite conservar otra información, como un índice, en situaciones en las que esa información no está disponible después de ejecutar la función.

```Javascript
function tabsHandler(index) {
    return function tabClickEvent(evt) {
        // Do stuff with tab.
        // The index variable can be accessed from within here.
    };
}

let tabs = document.querySelectorAll('.tab'),
    i;

for (i = 0; i &lt; tabs.length; i += 1) {
    tabs[i].onclick = tabsHandler(i);
}
```

Los controladores de eventos adjuntos se ejecutan más tarde (una vez que se completa el ciclo), por lo que se necesita un cierre para almacenar el valor correspondiente del ciclo for.

```Javascript
// Bad code, demonstrating why a closure is needed
let i;

for (i = 0; i &lt; list.length; i += 1) {
    document.querySelector('#item' + i).onclick = function doSomething(evt) {
        // Do something with item i
        // But, by the time this function executes, the value of i is always list.length
    }
}
```

Es más fácil entender por qué ocurre el problema si extraes la función doSomething del bucle for.

```Javascript
// Bad code, demonstrating why a closure is needed

let list = document.querySelectorAll('.item'),
    i,
    doSomething = function (evt) {
        // Do something with item i.
        // But, by the time this function executes, the value of i is not what it was in the loop.
    };

for (i = 0; i &lt; list.length; i += 1) {
    item[i].onclick = doSomething;
}
```

La solución es pasar el índice como argumento a la función externa para que pueda pasar ese valor a la función interna. A menudo verá funciones de controlador utilizadas para organizar la información que necesita una función de retorno interna.

```Javascript
// The following is good code, demonstrating the use of a closure

let list = ['item1', 'item2', 'item3'],
    i,
    doSomethingHandler = function (itemIndex) {
        return function doSomething(evt) {
            // now this doSomething function can retain knowledge of
            // the index variable via the itemIndex parameter,
            // along with other variables that may be available too.
            console.log('Doing something with ' + list[itemIndex]);
        };
    };

for (i = 0; i &lt; list.length; i += 1) {
    list[i].onclick = doSomethingHandler(i);
}
```

### Pasar una expresión de función como argumento

Las expresiones de funciones se pueden pasar directamente a funciones sin la necesidad de una asignación de variable temporal intermedia.

La mayoría de las veces las verás como funciones anónimas. Aquí hay un ejemplo familiar de una expresión de función jQuery:

```Javascript
$(document).ready(function () {
    console.log('An anonymous function');
});
```

También se utiliza una expresión de función para procesar elementos de matriz cuando se utiliza un método como forEach().

No deberían ser funciones anónimas sin nombre. Es una buena idea darle un nombre a la expresión de la función, esto ayudará a expresar para qué sirve la función y ayudará con la depuración:

```Javascript
let productIds = ['12356', '13771', '15492'];

productIds.forEach(function showProduct(productId) {
    ...
});
```

## Expresiones de funciones invocadas inmediatamente (IIFE)

Los IIFE ayudan a evitar que sus funciones y variables afecten el alcance global.

Todas las propiedades incluidas están dentro del alcance de la función anónima. Este es un patrón de diseño común para evitar que aparezcan efectos secundarios inesperados y no deseados en su código.

También se utilizan como plantilla de módulo para colocar códigos de bloque en secciones que sean fáciles de mantener.

Ejemplo simple de IIFE:

```Javascript
(function () {
    // code in here
}());
```

...que, cuando se utiliza como módulo, puede facilitar el mantenimiento del código.

```Javascript
let myModule = (function () {
    let privateMethod = function () {
        console.log('A private method');
    },
    someMethod = function () {
        console.log('A public method');
    },
    anotherMethod = function () {
        console.log('Another public method');
    };

    return {
        someMethod: someMethod,
        anotherMethod: anotherMethod
    };
}());
```

---

---

# ¿Qué es la palabra clave "this" en JS?

Es "eso", pero lo que significa exactamente depende del contexto.

La palabra clave **this** es una de las características de JavaScript. Originariamente surgió de Java para ayudar a implementar la programación orientada a objetos. Y la peculiaridad es que esta palabra puede significar diferentes objetos dependiendo de dónde se escriba. Veamos cómo funciona usando ejemplos de código.

## Qué es this

En JavaScript, **this** es una referencia a algún objeto. La peculiaridad es que el objeto al que hace referencia **this** puede cambiar según el contexto de la llamada. Es como señalar con el dedo algo en el código y decir: "Aquí me refiero a este objeto". El truco es que **this** en el código puede ser diferente, y todo depende de quién quiera usar este objeto.

La mayoría de las veces, **this** lo determina quien llama a la función. Ésta es su diferencia con el alcance, que está determinado por el lugar donde se llama la función. Debido a esto, a menudo puedes encontrar muchas llamadas **this** en el código, pero se referirán a objetos diferentes.

Ahora veamos cómo cambia el valor de **this** en diferentes situaciones: desde una simple llamada sin contexto hasta funciones complejas.

## llamada sencilla

En general, **this** apunta a un objeto global. Para un navegador, dicho objeto es la propia ventana del navegador, por lo que si escribe en la consola del navegador

```Javascript
console.log(this);
```

luego veremos que aquí **this** está vinculado al contexto global, es decir, al objeto de ventana en el navegador.

```Javascript
Window {window: Window, self: Window, document: document, name: '', location: Location, …}
```

Cuando el modo estricto está habilitado en JS, las reglas cambian. Si la función se llama en modo **use strict**, entonces **this** será **undefined**.

## This se refiere a un objeto

Cuando **this** se usa dentro de un objeto, se refiere al objeto mismo. Digamos que creamos un objeto _dog_ con tres métodos y usamos **this** en uno de sus métodos. Dado que **this** dentro de un método apunta al objeto actual en cuyo contexto se llamó el método, en nuestro ejemplo obtendremos una referencia al objeto _dog_.

Escribamos un código simple con un objeto e imprimamos el valor de **this** en la consola:

```Javascript
var dog = {
  name: 'Cheems',
  breed: 'Shiba Inu',
  intro: function(){
    console.log(this);
  }
};

dog.intro();
```

En la consola veremos una representación del objeto con todos los métodos:

```Javascript
{name: 'Cheems', breed: 'Shiba Inu', intro: ƒ}
```

Usar **this** hace que el código sea más flexible. El valor de **this** está en sí mismo vinculado al objeto en cuyo contexto se llama. Esto permite que el método funcione con datos de una instancia específica de un objeto y haga que el código sea más universal.

## Modo de diseño

Un constructor es una función que se utiliza para crear objetos del mismo tipo. El nombre de un constructor en JavaScript debe ser un sustantivo y comenzar con letra mayúscula. Los constructores se llaman usando la palabra clave **new**. La tarea del diseñador es explicarle a la computadora qué parámetros y propiedades serán necesarios para crear un nuevo objeto.

Hagamos un constructor y creemos un nuevo objeto. Observe cómo usamos **this**: automáticamente apunta al objeto en el constructor actual desde donde se llama:

```Javascript
function Dog () {
// this está vinculado al nuevo objeto
  this.name = 'Cheems'
}

// crea un nuevo objeto Dog
const firstDog = new Dog()
firstDog.name === 'Cheems'

console.log(firstDog.name);
```

```Javascript
Cheems
```

Este enfoque es conveniente porque con la ayuda de **this** y una única función constructora podemos crear muchos objetos del mismo tipo e indicar directamente a qué objeto estamos accediendo.

Vamos a mostrar cómo funciona esto usando el ejemplo de una función constructora para crear objetos de automóvil:

```Javascript
function Car(brand, model, year) {

// используем this, чтобы установить свойства объектов
  this.brand = brand;
  this.model = model;
  this.year = year;
}

// создаём новые объекты с помощью функции-конструктора
const car1 = new Car('Toyota', 'Camry', 2022);
const car2 = new Car('Honda', 'Accord', 2021);
const car3 = new Car('Ford', 'Mustang', 2020);

console.log(car1);
console.log(car2);
console.log(car3);
```

```Javascript
Car {brand: 'Toyota', model: 'Camry', year: 2022}
Car {brand: 'Honda', model: 'Accord', year: 2021}
Car {brand: 'Ford', model: 'Mustang', year: 2020}
```

Si tuviéramos que escribir una lógica similar sin usar **this**, primero crearíamos un nuevo objeto, estableceríamos sus propiedades, devolveríamos el objeto y luego crearíamos otros nuevos. Entonces el código sería más engorroso.

## Trabajar con los métodos call() y apply()

En JS, los objetos suelen tener sus propias propiedades y métodos, y diferentes objetos no pueden simplemente usar los métodos de los demás. Pero a veces es necesario sortear esta limitación. Para hacer esto, use los métodos **call()** y **apply()**; le permiten llamar a las funciones necesarias en el contexto de otros objetos. Para pasar el contexto requerido a una función, se usa **this**: almacena el contexto de llamada, que no cambia cuando se pasa a otra función.

Llamar a una función a través de los métodos **call()** o **apply()** se denomina llamada indirecta.

Hay una ligera diferencia en la sintaxis de los métodos: **call()** toma una lista de argumentos separados por comas, **apply()** toma una serie de argumentos. Por lo demás, funcionan, más o menos, igual.

Para mayor claridad, hagamos esto:

1. Creemos una función que tome una palabra de saludo y un emoticón como argumento.
2. Dentro de esta función usamos **this**; esto nos ayudará a obtener el contexto del objeto que llamó a esta función.
3. Creemos dos variables con nombres.
4. Llamemos a la función de saludo usando variables con nombre como argumentos.
5. Como usamos **this** dentro de la función, obtendrá el contexto necesario: lo transferirá desde las variables nombradas.
6. Como resultado, la función de saludo de contexto entenderá que debemos tomar los nombres de las variables y agregarlos a la salida de la consola.

```Javascript
function greet(greetWord, emoticon) {
  console.log(`${greetWord} ${this.name} ${emoticon}`)
}

const user1 = { name: 'Barbie' }
const user2 = { name: 'Ken' }

greet.call(user1, 'Hi,', ':-)')
greet.call(user2, 'Hello,', ':-D')
greet.apply(user1, ['Hi,', ':-)'])
greet.apply(user2, ['Hello,', ':-D'])
```

```Javascript
Hi, Barbie :-)
Hello, Ken :-D
Hi, Barbie :-)
Hello, Ken :-D
```

## Funciones de flecha

Una función de flecha no crea su propio contexto de ejecución, sino que lo toma de su función externa en la que está definida esta función de flecha.

Creemos una función que imprima el saludo y el nombre de usuario, y luego repita el saludo después de un tiempo:

```Javascript
function greetWaitAndAgain() {
  console.log(`Hi, ${this.name}!`)
  setTimeout(() => {
    console.log(`Hi again, ${this.name}!`)
  })
}

// crear un objeto
const user = { name: 'Barbie' }

// agrega un método al objeto
user.greetWaitAndAgain = greetWaitAndAgain;
user.greetWaitAndAgain()
```

```Javascript
Hi, Barbie!
Hi again, Barbie!
```

Si usáramos una función normal, el contexto se perdería y **this** ya no apuntaría al objeto _user_, y entonces tendríamos que usar la exportación indirecta. Por esta razón, **this** se usa a menudo en funciones de flecha para evitar sobrecargar el código con métodos adicionales.

## Cómo entender cuál es el valor de this

Determinamos a qué es igual **this** en cada caso concreto:

- Si no estamos dentro de una función, entonces **this** es igual al objeto global: la ventana del navegador.
- Si una función se recibe como propiedad de un objeto y se usa inmediatamente, entonces **this** será igual a ese objeto.
- Si se llama a una función usando el operador **new**, entonces **this** se referirá al objeto recién creado en el constructor de la función.
- Si una función se crea usando el método **call\* o **apply**, entonces el valor de **this\*\* será el argumento de esa función.
- Si estamos dentro de una función de flecha, entonces **this** es igual al valor de **this** fuera de la función.
